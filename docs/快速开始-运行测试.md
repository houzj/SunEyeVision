# 快速开始:运行工作流执行引擎测试

## 一、准备工作

### 1. 确认项目已编译
```bash
cd d:/MyWork/SunEyeVision/SunEyeVision
dotnet build SunEyeVision.Workflow/SunEyeVision.Workflow.csproj --configuration Release
```

### 2. 确认插件已加载
确保在应用启动时插件正确加载到ToolRegistry。

## 二、立即开始测试(推荐方法)

### 方法: 在现有应用中添加测试菜单

#### 步骤1: 在SunEyeVision.UI中创建测试服务

创建文件: `SunEyeVision.UI/Services/TestExecutionService.cs`

```csharp
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using SunEyeVision.Interfaces;
using SunEyeVision.Workflow.Tests;

namespace SunEyeVision.UI.Services
{
    /// <summary>
    /// 测试执行服务 - 在应用中集成测试
    /// </summary>
    public class TestExecutionService
    {
        private readonly ILogger _logger;
        private WorkflowExecutionTests? _tests;

        public TestExecutionService(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// 初始化测试套件
        /// </summary>
        public void Initialize()
        {
            _tests = new WorkflowExecutionTests(_logger);
        }

        /// <summary>
        /// 运行所有测试
        /// </summary>
        public async Task RunAllTestsAsync()
        {
            if (_tests == null)
            {
                _logger.LogError("测试套件未初始化");
                return;
            }

            await _tests.RunAllTests();
        }

        /// <summary>
        /// 运行单个测试
        /// </summary>
        public async Task RunSpecificTestAsync(string testName)
        {
            if (_tests == null)
            {
                _logger.LogError("测试套件未初始化");
                return;
            }

            switch (testName.ToLower())
            {
                case "sequential":
                    await _tests.TestSequentialExecution();
                    break;
                case "parallel":
                    await _tests.TestParallelExecution();
                    break;
                case "hybrid":
                    await _tests.TestHybridExecution();
                    break;
                case "caching":
                    await _tests.TestCachingDecorator();
                    break;
                case "strategy":
                    await _tests.TestStrategySelection();
                    break;
                default:
                    _logger.LogError($"未知测试: {testName}");
                    break;
            }
        }
    }
}
```

#### 步骤2: 在MainWindow.xaml中添加测试菜单

打开 `SunEyeVision.UI/MainWindow.xaml`,在菜单栏中添加:

```xml
<!-- 找到菜单部分,添加测试菜单 -->
<Menu>
    <MenuItem Header="文件(_F)">
        <!-- 现有菜单项 -->
    </MenuItem>
    
    <MenuItem Header="编辑(_E)">
        <!-- 现有菜单项 -->
    </MenuItem>
    
    <!-- 新增测试菜单 -->
    <MenuItem Header="测试(_T)">
        <MenuItem Header="运行所有测试(_A)" Command="{Binding RunAllTestsCommand}" />
        <Separator />
        <MenuItem Header="顺序执行测试(_S)" Command="{Binding RunSequentialTestCommand}" />
        <MenuItem Header="并行执行测试(_P)" Command="{Binding RunParallelTestCommand}" />
        <MenuItem Header="混合执行测试(_H)" Command="{Binding RunHybridTestCommand}" />
        <Separator />
        <MenuItem Header="缓存装饰器测试(_C)" Command="{Binding RunCachingTestCommand}" />
        <MenuItem Header="策略选择测试(_V)" Command="{Binding RunStrategyTestCommand}" />
    </MenuItem>
    
    <!-- 其他菜单 -->
</Menu>
```

#### 步骤3: 在MainWindowViewModel中添加测试命令

打开 `SunEyeVision.UI/ViewModels/MainWindowViewModel.cs`,添加:

```csharp
using SunEyeVision.UI.Services;

public class MainWindowViewModel
{
    // 添加测试服务
    private readonly TestExecutionService _testService;
    
    // 测试命令
    public ICommand RunAllTestsCommand { get; private set; }
    public ICommand RunSequentialTestCommand { get; private set; }
    public ICommand RunParallelTestCommand { get; private set; }
    public ICommand RunHybridTestCommand { get; private set; }
    public ICommand RunCachingTestCommand { get; private set; }
    public ICommand RunStrategyTestCommand { get; private set; }

    // 在构造函数中初始化
    public MainWindowViewModel(/* 现有参数 */)
    {
        // 现有初始化代码...
        
        // 初始化测试服务
        _testService = new TestExecutionService(logger);
        _testService.Initialize();

        // 初始化测试命令
        RunAllTestsCommand = new RelayCommand(async () => await _testService.RunAllTestsAsync());
        RunSequentialTestCommand = new RelayCommand(async () => await _testService.RunSpecificTestAsync("sequential"));
        RunParallelTestCommand = new RelayCommand(async () => await _testService.RunSpecificTestAsync("parallel"));
        RunHybridTestCommand = new RelayCommand(async () => await _testService.RunSpecificTestAsync("hybrid"));
        RunCachingTestCommand = new RelayCommand(async () => await _testService.RunSpecificTestAsync("caching"));
        RunStrategyTestCommand = new RelayCommand(async () => await _testService.RunSpecificTestAsync("strategy"));
    }
}
```

**注意**: 如果你的项目没有RelayCommand,可以使用其他ICommand实现,例如:
```csharp
public class RelayCommand : ICommand
{
    private readonly Func<Task> _execute;
    private readonly Func<bool>? _canExecute;

    public RelayCommand(Func<Task> execute, Func<bool>? canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public event EventHandler? CanExecuteChanged;

    public bool CanExecute(object? parameter) => _canExecute?.Invoke() ?? true;

    public async void Execute(object? parameter) => await _execute();

    public void RaiseCanExecuteChanged() => CanExecuteChanged?.Invoke(this, EventArgs.Empty);
}
```

#### 步骤4: 编译并运行

```bash
# 编译项目
dotnet build SunEyeVision.UI/SunEyeVision.UI.csproj --configuration Release

# 运行应用
dotnet run --project SunEyeVision.UI/SunEyeVision.UI.csproj --configuration Release
```

#### 步骤5: 运行测试

应用启动后:
1. 点击菜单 **测试(T)**
2. 选择 **运行所有测试(A)**
3. 查看日志窗口中的测试输出

## 三、测试输出示例

运行所有测试后,日志窗口应显示:

```
========================================
SunEyeVision 工作流执行引擎测试
========================================

[INFO]  ========== 测试1: 顺序执行工作流 ==========
[INFO]  选择执行策略: Sequential
[INFO]  使用顺序执行模式
[INFO]  ========== 节点执行顺序 (共3个节点) ==========
[INFO]    [1] node1 - 高斯模糊
[INFO]    [2] node2 - 边缘检测
[INFO]    [3] node3 - 阈值处理
[INFO]  =====================================================
[INFO]  [1/3] 开始执行节点: 高斯模糊 (ID: node1)
...
[INFO]  ✓ 测试通过: 顺序执行成功, 耗时 185.50ms

[INFO]  ========== 测试2: 并行执行工作流 ==========
[INFO]  选择执行策略: Parallel
[INFO]  使用并行执行模式
[INFO]  检测到1条执行链
...
[INFO]  ✓ 测试通过: 并行执行成功, 耗时 108.30ms

[INFO]  ========== 测试3: 混合执行工作流 ==========
...
[INFO]  ✓ 测试通过: 混合执行成功, 耗时 142.70ms

[INFO]  ========== 测试4: 缓存装饰器效果 ==========
[INFO]  第一次执行: 185.50ms
[INFO]  第二次执行: 15.30ms
[INFO]  性能提升: 91.8%
[INFO]  ✓ 测试通过: 缓存生效, 性能提升

[INFO]  ========== 测试5: 智能策略选择 ==========
[INFO]  简单顺序工作流选择策略: Sequential
[INFO]  并行工作流选择策略: Parallel
[INFO]  混合工作流选择策略: Hybrid
[INFO]  ✓ 测试通过: 策略选择功能正常

========================================
所有测试完成
========================================
```

## 四、在真实工作流中测试

除了自动化测试,你也可以在真实工作流中验证:

### 测试1: 顺序工作流
1. 在画布中创建节点: blur1 → edge1 → thresh1
2. 不使用Start节点
3. 执行工作流
4. 验证日志显示"顺序执行模式"

### 测试2: 并行工作流
1. 在画布中创建节点:
   - start → blur1
   - start → edge1
   - start → thresh1
2. 执行工作流
3. 验证日志显示"并行执行模式"
4. 验证执行时间明显缩短

### 测试3: 混合工作流
1. 在画布中创建节点:
   - start1 → blur1 → edge1
   - start2 → gray1 → thresh1
2. 执行工作流
3. 验证日志显示"混合执行模式"
4. 验证两条链并行执行

## 五、故障排查

### 问题: 测试菜单未显示
**解决**: 检查MainWindow.xaml中是否正确添加了菜单项

### 问题: 点击测试按钮无反应
**解决**: 
1. 检查TestExecutionService是否正确初始化
2. 查看日志窗口是否有错误信息
3. 确认WorkflowExecutionTests类存在

### 问题: 测试输出未显示
**解决**:
1. 确保日志窗口打开
2. 检查日志级别设置
3. 查看输出窗口(Output)

### 问题: 工具不存在警告
**解决**:
1. 这是正常的,会自动使用TestImageProcessor后备
2. 如需使用真实插件,确保插件正确加载

## 六、下一步

测试完成后,记录结果:
1. 记录每个测试的执行时间
2. 记录性能提升百分比
3. 记录任何异常或错误
4. 提供反馈用于后续优化

## 七、参考文档

- 完整测试指南: `docs/SunEyeVision真实测试框架指南.md`
- 优化方案: `docs/工作流执行引擎优化方案.md`
- 实施总结: `docs/工作流执行引擎优化实施总结.md`
