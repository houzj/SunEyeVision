# 节点执行顺序逻辑详解

## 概述

本文档详细说明了SunEyeVision工作流系统的节点执行顺序管理逻辑，包括当前实现的问题分析、优化方案及各种执行场景的处理方式。

---

## 1. 当前实现分析

### 1.1 现有节点类型

```csharp
public enum NodeType
{
    Algorithm,  // 算法节点
    Input,      // 输入节点
    Output,     // 输出节点
    Condition   // 条件节点
}
```

### 1.2 当前执行顺序机制

当前系统使用**拓扑排序**确定节点执行顺序，核心方法为 `Workflow.GetExecutionOrder()`：

```csharp
public List<string> GetExecutionOrder()
{
    var order = new List<string>();
    var visited = new HashSet<string>();
    var tempVisited = new HashSet<string>();

    void Visit(string nodeId)
    {
        if (tempVisited.Contains(nodeId)) return;
        if (visited.Contains(nodeId)) return;

        tempVisited.Add(nodeId);
        visited.Add(nodeId);
        order.Add(nodeId);  // 前序遍历

        if (Connections.ContainsKey(nodeId))
        {
            foreach (var dependentId in Connections[nodeId])
            {
                Visit(dependentId);
            }
        }
        tempVisited.Remove(nodeId);
    }

    foreach (var node in Nodes)
    {
        Visit(node.Id);
    }

    return order;
}
```

### 1.3 GetNodeInput方法实现（问题所在）

```csharp
private Mat GetNodeInput(Workflow workflow, WorkflowNode node, Mat defaultInput, Dictionary<string, Mat> nodeResults)
{
    var parentIds = workflow.Connections
        .Where(kvp => kvp.Value.Contains(node.Id))
        .Select(kvp => kvp.Key)
        .ToList();

    // 问题：只返回第一个可用父节点的输出
    foreach (var parentId in parentIds)
    {
        if (nodeResults.ContainsKey(parentId))
        {
            return nodeResults[parentId];  // ❌ 数据丢失
        }
    }

    return defaultInput;
}
```

**问题分析**：
- 当一个节点有多个父节点时，只使用第一个父节点的输出
- 忽略了其他父节点的数据，导致**数据丢失**
- 无法真正实现并行执行链的数据汇聚

---

## 2. 最终优化方案

### 2.1 统一NodeType枚举

```csharp
/// <summary>
/// 统一的节点类型枚举
/// </summary>
public enum NodeType
{
    // ==================== 流程控制类型 ====================
    
    /// <summary>
    /// 开始节点 - 标记独立的并行执行链起点
    /// </summary>
    Start,
    
    /// <summary>
    /// 结束节点 - 标记执行链终点
    /// </summary>
    End,
    
    // ==================== 数据处理类型 ====================
    
    /// <summary>
    /// 算法节点 - 执行图像处理算法
    /// </summary>
    Algorithm,
    
    /// <summary>
    /// 输入节点 - 数据源节点（如图像采集）
    /// </summary>
    Input,
    
    /// <summary>
    /// 输出节点 - 数据输出节点
    /// </summary>
    Output,
    
    // ==================== 逻辑控制类型 ====================
    
    /// <summary>
    /// 子程序节点 - 可复用的子工作流
    /// </summary>
    Subroutine,
    
    /// <summary>
    /// 条件节点 - 条件分支控制
    /// </summary>
    Condition,
    
    /// <summary>
    /// 循环节点 - 循环控制
    /// </summary>
    Loop,
    
    /// <summary>
    /// 分支节点 - 多路分支
    /// </summary>
    Switch,
    
    /// <summary>
    /// 异常捕获节点 - 错误处理
    /// </summary>
    TryCatch
}
```

**设计说明**：
- **移除了**与 `WorkflowControlType` 的混淆
- 明确分为三类：流程控制、数据处理、逻辑控制
- **Start节点**是本次优化的核心，用于标记并行执行链的起点

### 2.2 优化GetNodeInput方法

```csharp
/// <summary>
/// 获取节点输入 - 总是返回所有父节点的输出
/// </summary>
/// <returns>
/// - 无父节点：返回 defaultInput
/// - 单个父节点：返回父节点输出（object类型）
/// - 多个父节点：返回 List<object>，包含所有父节点输出
/// </returns>
private object GetNodeInput(Workflow workflow, WorkflowNode node, object defaultInput, Dictionary<string, object> nodeResults)
{
    // 查找所有父节点
    var parentIds = workflow.Connections
        .Where(kvp => kvp.Value.Contains(node.Id))
        .Select(kvp => kvp.Key)
        .ToList();

    if (!parentIds.Any())
    {
        // 无父节点，返回默认输入
        return defaultInput;
    }

    // 收集所有可用父节点的输出
    var parentOutputs = new List<object>();
    foreach (var parentId in parentIds)
    {
        if (nodeResults.ContainsKey(parentId))
        {
            parentOutputs.Add(nodeResults[parentId]);
        }
    }

    if (parentOutputs.Count == 0)
    {
        // 父节点尚未执行完成，返回默认输入
        return defaultInput;
    }

    if (parentOutputs.Count == 1)
    {
        // 单个父节点，直接返回其输出
        return parentOutputs[0];
    }

    // 多个父节点，返回所有输出
    return parentOutputs;
}
```

**核心改进**：
- ✅ 总是返回所有父节点的输出
- ✅ 单个父节点时直接返回该节点的输出
- ✅ 多个父节点时返回 `List<object>`
- ✅ 无复杂策略选择，逻辑简单清晰

### 2.3 执行链管理 - 基于Start节点

#### 2.3.1 数据结构

```csharp
/// <summary>
/// 执行链 - 由Start节点驱动的独立执行单元
/// </summary>
public class ExecutionChain
{
    /// <summary>
    /// 执行链唯一标识
    /// </summary>
    public string ChainId { get; set; }

    /// <summary>
    /// 起始节点ID
    /// </summary>
    public string StartNodeId { get; set; }

    /// <summary>
    /// 执行链中的节点ID列表（按拓扑顺序）
    /// </summary>
    public List<string> NodeIds { get; set; }

    /// <summary>
    /// 执行链中的所有依赖（用于跨链同步）
    /// </summary>
    public List<ChainDependency> Dependencies { get; set; }
}

/// <summary>
/// 执行链依赖关系
/// </summary>
public class ChainDependency
{
    /// <summary>
    /// 依赖的源链ID
    /// </summary>
    public string SourceChainId { get; set; }

    /// <summary>
    /// 源节点ID
    /// </summary>
    public string SourceNodeId { get; set; }

    /// <summary>
    /// 本链中依赖该源的节点ID
    /// </summary>
    public string TargetNodeId { get; set; }
}
```

#### 2.3.2 获取Start驱动执行链

```csharp
/// <summary>
/// 获取Start驱动执行链列表
/// </summary>
public List<ExecutionChain> GetStartDrivenExecutionChains()
{
    var chains = new List<ExecutionChain>();
    var allVisitedNodes = new HashSet<string>();
    var chainIndex = 0;

    // 获取所有Start节点
    var startNodes = Nodes.Where(n => n.Type == NodeType.Start).ToList();

    if (startNodes.Count == 0)
    {
        // 向后兼容：无Start节点时，创建默认执行链
        chains.Add(new ExecutionChain
        {
            ChainId = "default",
            NodeIds = GetExecutionOrder()
        });
        return chains;
    }

    // 为每个Start节点创建执行链
    foreach (var startNode in startNodes)
    {
        var chain = new ExecutionChain
        {
            ChainId = $"chain_{chainIndex}",
            StartNodeId = startNode.Id,
            NodeIds = new List<string>(),
            Dependencies = new List<ChainDependency>()
        };

        // 收集执行链中的节点
        CollectExecutionChain(startNode.Id, chain.NodeIds, allVisitedNodes);

        // 分析跨链依赖关系
        AnalyzeChainDependencies(chain, allVisitedNodes);

        chains.Add(chain);
        chainIndex++;
    }

    return chains;
}

/// <summary>
/// 收集执行链中的节点
/// </summary>
private void CollectExecutionChain(
    string nodeId,
    List<string> chainNodes,
    HashSet<string> allVisitedNodes)
{
    if (allVisitedNodes.Contains(nodeId) || chainNodes.Contains(nodeId))
    {
        return;
    }

    chainNodes.Add(nodeId);
    allVisitedNodes.Add(nodeId);

    // 递归收集下游节点
    if (Connections.ContainsKey(nodeId))
    {
        foreach (var childId in Connections[nodeId])
        {
            CollectExecutionChain(childId, chainNodes, allVisitedNodes);
        }
    }
}

/// <summary>
/// 分析跨链依赖关系
/// </summary>
private void AnalyzeChainDependencies(ExecutionChain chain, HashSet<string> allVisitedNodes)
{
    foreach (var nodeId in chain.NodeIds)
    {
        var parentIds = Connections
            .Where(kvp => kvp.Value.Contains(nodeId))
            .Select(kvp => kvp.Key)
            .ToList();

        foreach (var parentId in parentIds)
        {
            // 如果父节点不在本链中，则创建跨链依赖
            if (!chain.NodeIds.Contains(parentId))
            {
                chain.Dependencies.Add(new ChainDependency
                {
                    SourceNodeId = parentId,
                    TargetNodeId = nodeId
                });
            }
        }
    }
}
```

### 2.4 并行执行引擎

```csharp
/// <summary>
/// 并行执行工作流（支持多个执行链）
/// </summary>
private async Task<ExecutionResult> ExecuteWorkflowParallel(
    Workflow workflow,
    Mat inputImage,
    WorkflowContext context)
{
    var result = new ExecutionResult();
    var nodeResults = new ConcurrentDictionary<string, object>();  // 线程安全
    var nodeExecutionResults = new ConcurrentDictionary<string, NodeExecutionResult>();

    // 获取执行链
    var chains = workflow.GetStartDrivenExecutionChains();

    _logger.LogInfo($"========== 执行链分析 (共{chains.Count}条链) ==========");
    for (int i = 0; i < chains.Count; i++)
    {
        var chain = chains[i];
        _logger.LogInfo($"  执行链[{i}]: {chain.ChainId}");
        _logger.LogInfo($"    - 起始节点: {chain.StartNodeId}");
        _logger.LogInfo($"    - 节点数量: {chain.NodeIds.Count}");
        _logger.LogInfo($"    - 跨链依赖: {chain.Dependencies.Count}");
    }
    _logger.LogInfo($"=====================================================");

    // 并行执行所有链
    var chainTasks = chains.Select(async chain =>
    {
        return await ExecuteChainSequential(workflow, chain, inputImage, context, nodeResults, nodeExecutionResults);
    }).ToList();

    // 等待所有链执行完成
    var chainResults = await Task.WhenAll(chainTasks);

    // 合并所有链的结果
    foreach (var chainResult in chainResults)
    {
        result.Merge(chainResult);
    }

    result.Success = result.Errors.Count == 0;
    result.ExecutionTime = DateTime.Now - _executionStartTime;

    ExecutionCompleted?.Invoke(this, result);
    return result;
}

/// <summary>
/// 顺序执行单个执行链
/// </summary>
private async Task<ExecutionResult> ExecuteChainSequential(
    Workflow workflow,
    ExecutionChain chain,
    object defaultInput,
    WorkflowContext context,
    ConcurrentDictionary<string, object> nodeResults,
    ConcurrentDictionary<string, NodeExecutionResult> nodeExecutionResults)
{
    var result = new ExecutionResult();

    _logger.LogInfo($"========== 开始执行链: {chain.ChainId} ==========");

    foreach (var nodeId in chain.NodeIds)
    {
        if (_cancellationTokenSource?.IsCancellationRequested == true)
        {
            throw new OperationCanceledException();
        }

        var node = workflow.Nodes.FirstOrDefault(n => n.Id == nodeId);
        if (node == null || !node.IsEnabled)
        {
            continue;
        }

        var nodeStartTime = DateTime.Now;

        _logger.LogInfo($"  执行节点: {node.Name} (ID: {nodeId})");

        context.UpdateNodeStatus(nodeId, NodeStatus.Running);
        NodeStatusChanged?.Invoke(this, new NodeExecutionStatus { NodeId = nodeId, Status = NodeStatus.Running });

        // 获取节点输入（可能是单个对象或List<object>）
        var nodeInput = GetNodeInput(workflow, node, defaultInput, nodeResults.ToDictionary(kvp => kvp.Key, kvp => kvp.Value));

        // 执行节点
        var nodeResult = await ExecuteNode(node, nodeInput, context, workflow);

        var nodeDuration = (DateTime.Now - nodeStartTime).TotalMilliseconds;

        // 记录结果到线程安全字典
        if (nodeResult.Success && nodeResult.Outputs?.Any() == true)
        {
            nodeResults.TryAdd(nodeId, nodeResult.Outputs.Values.First());
        }

        nodeExecutionResults.TryAdd(nodeId, nodeResult);
        context.UpdateNodeStatus(nodeId, nodeResult.Success ? NodeStatus.Completed : NodeStatus.Failed);

        if (!nodeResult.Success)
        {
            var errorMessage = nodeResult.ErrorMessages?.FirstOrDefault() ?? "执行失败";
            result.AddError(errorMessage, nodeId);
        }
    }

    _logger.LogInfo($"========== 执行链完成: {chain.ChainId} ==========");

    return result;
}
```

---

## 3. 各种场景执行逻辑详解

### 3.1 场景一：单个Start节点

#### 工作流结构
```
[Start1] -> [NodeA] -> [NodeB] -> [NodeC]
```

#### 执行逻辑
1. **执行链识别**：
   - 检测到1个Start节点：Start1
   - 创建执行链：Chain1

2. **执行顺序**：
   ```
   Chain1: [Start1, NodeA, NodeB, NodeC]
   ```

3. **节点输入获取**：
   - Start1: 无父节点，使用 defaultInput
   - NodeA: 父节点 = [Start1]，返回 Start1 的输出
   - NodeB: 父节点 = [NodeA]，返回 NodeA 的输出
   - NodeC: 父节点 = [NodeB]，返回 NodeB 的输出

4. **执行结果**：
   ```
   Start1 输出 → NodeA → NodeB → NodeC
   ```
   ✅ 数据流清晰，无数据丢失

---

### 3.2 场景二：一个Start下，多个目标节点依赖同一个源节点

#### 工作流结构
```
        [NodeB]
       ↗        ↘
[Start1]          [NodeD]
       ↘        ↗
        [NodeC]
```

#### 执行逻辑
1. **执行链识别**：
   - 检测到1个Start节点：Start1
   - 创建执行链：Chain1

2. **执行顺序**（拓扑排序）：
   ```
   Chain1: [Start1, NodeB, NodeC, NodeD]
   ```

3. **节点输入获取**：
   - Start1: 无父节点，使用 defaultInput
   - NodeB: 父节点 = [Start1]，返回 Start1 的输出
   - NodeC: 父节点 = [Start1]，返回 Start1 的输出
   - NodeD: 父节点 = [NodeB, NodeC]，返回 List<object>，包含 [NodeB输出, NodeC输出]

4. **执行结果**：
   ```
   Start1 输出 ──┬──→ NodeB ──┐
                │             │
                └──→ NodeC ──┴──→ NodeD (接收到[NodeB输出, NodeC输出])
   ```

5. **NodeD的输入处理**：
   ```csharp
   var nodeInput = GetNodeInput(workflow, nodeD, defaultInput, nodeResults);
   // nodeInput 类型: List<object>，包含两个元素
   // 元素[0]: NodeB的输出
   // 元素[1]: NodeC的输出
   ```

   ✅ **不会丢失数据**，NodeD可以同时使用NodeB和NodeC的输出

---

### 3.3 场景三：一个目标节点依赖多个源节点

#### 工作流结构
```
[Start1] -> [NodeA] ─┐
                    ├──→ [NodeD]
[Start2] -> [NodeB] ─┘
```

#### 执行逻辑
1. **执行链识别**：
   - 检测到2个Start节点：Start1, Start2
   - 创建2条执行链：
     - Chain1: [Start1, NodeA]
     - Chain2: [Start2, NodeB]

2. **跨链依赖分析**：
   - NodeD的父节点：[NodeA, NodeB]
   - NodeA在Chain1，NodeB在Chain2
   - **NodeD需要等待两个链都完成**

3. **并行执行**：
   ```
   Chain1: [Start1, NodeA]     (Task 1)
   Chain2: [Start2, NodeB]     (Task 2)
   ```
   - 使用 `Task.WhenAll` 等待两条链都完成

4. **NodeD的输入获取**：
   ```csharp
   var nodeInput = GetNodeInput(workflow, nodeD, defaultInput, nodeResults);
   // nodeInput 类型: List<object>，包含两个元素
   // 元素[0]: NodeA的输出（来自Chain1）
   // 元素[1]: NodeB的输出（来自Chain2）
   ```

5. **执行结果**：
   ```
   Chain1: Start1 → NodeA ──┐
   Chain2: Start2 → NodeB ──┼──→ NodeD (接收到[NodeA输出, NodeB输出])
   ```

   ✅ **真正的并行执行**，两条链同时运行，然后NodeD汇聚结果

---

### 3.4 场景四：混合场景

#### 工作流结构
```
        [NodeB]
       ↗        ↘
[Start1]          [NodeD] ──→ [NodeF]
       ↘        ↗
        [NodeC]

[Start2] -> [NodeE] ──→ [NodeF]
```

#### 执行逻辑
1. **执行链识别**：
   - Chain1: [Start1, NodeB, NodeC, NodeD, NodeF]
   - Chain2: [Start2, NodeE, NodeF]

2. **执行顺序**（拓扑排序）：
   ```
   Chain1: [Start1, NodeB, NodeC, NodeD, NodeF]
   Chain2: [Start2, NodeE, NodeF]
   ```

3. **并行执行**：
   ```
   Chain1: Start1 → NodeB ↘
                   NodeC ↗
                          → NodeD ↘
   Chain2: Start2 → NodeE ↗
                          → NodeF
   ```

4. **节点输入获取**：
   - NodeD: 父节点 = [NodeB, NodeC]，返回 List<object>，包含 [NodeB输出, NodeC输出]
   - NodeF: 父节点 = [NodeD, NodeE]，返回 List<object>，包含 [NodeD输出, NodeE输出]

5. **跨链同步**：
   - NodeF需要等待Chain1的NodeD和Chain2的NodeE都完成
   - 使用 `ConcurrentDictionary<string, object>` 线程安全地存储结果
   - 执行引擎等待所有依赖就绪后才执行NodeF

6. **执行结果**：
   ```
   Chain1: Start1 → [NodeB, NodeC] → NodeD ──┐
   Chain2: Start2 → NodeE ───────────────────┼──→ NodeF (接收到[NodeD输出, NodeE输出])
   ```

   ✅ **复杂的并行场景**完美支持，数据无丢失

---

### 3.5 场景五：无Start节点（向后兼容）

#### 工作流结构
```
[NodeA] -> [NodeB] -> [NodeC]
```

#### 执行逻辑
1. **执行链识别**：
   - 未检测到Start节点
   - 创建默认执行链：default

2. **执行顺序**：
   ```
   default: [NodeA, NodeB, NodeC]
   ```

3. **节点输入获取**：
   - NodeA: 无父节点，使用 defaultInput
   - NodeB: 父节点 = [NodeA]，返回 NodeA 的输出
   - NodeC: 父节点 = [NodeB]，返回 NodeB 的输出

4. **执行结果**：
   ```
   NodeA → NodeB → NodeC
   ```

   ✅ **向后兼容**，现有工作流无需修改

---

## 4. 核心改进总结

### 4.1 解决的问题

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| **数据丢失** | GetNodeInput只使用第一个父节点输出 | 返回所有父节点输出（List<object>） |
| **无法并行** | 顺序执行，无并行机制 | Start驱动执行链 + Task.WhenAll |
| **执行顺序不确定** | 依赖节点添加顺序 | 拓扑排序保证依赖关系 |
| **类型混淆** | NodeType和WorkflowControlType双重枚举 | 统一为NodeType，明确分类 |
| **复杂策略** | First/Last/Merge等7种策略 | 简化为"总是使用所有输出" |

### 4.2 技术亮点

1. **简单直接**：
   - 不需要复杂的策略配置
   - 不需要用户干预
   - 自动使用所有父节点输出

2. **真正并行**：
   - 多个执行链同时运行
   - 使用 `ConcurrentDictionary` 线程安全
   - 跨链依赖自动同步

3. **向后兼容**：
   - 无Start节点时自动创建默认链
   - 现有工作流无需修改

4. **数据完整性**：
   - 所有父节点输出都被保留
   - 无数据丢失
   - 支持多输入节点

---

## 5. 实施步骤

### 5.1 第一阶段：核心类型更新

1. 更新 `NodeType` 枚举
   - 添加 `Start`、`End` 等新类型
   - 重新组织分类

2. 更新 `WorkflowNode` 类
   - 确保支持新类型

### 5.2 第二阶段：执行逻辑优化

1. 重写 `GetNodeInput` 方法
   - 返回所有父节点输出
   - 处理单个/多个父节点的差异

2. 实现 `GetStartDrivenExecutionChains` 方法
   - 基于Start节点识别执行链
   - 分析跨链依赖

3. 实现 `ExecuteWorkflowParallel` 方法
   - 支持并行执行
   - 线程安全的结果存储

### 5.3 第三阶段：UI集成

1. 添加Start节点到工具箱
2. 更新节点创建UI
3. 可视化执行链（可选）

### 5.4 第四阶段：测试验证

1. 单元测试：GetNodeInput各种场景
2. 集成测试：各种工作流结构
3. 性能测试：并行执行效率

---

## 6. 代码示例

### 6.1 使用示例：创建并行工作流

```csharp
// 创建工作流
var workflow = new Workflow("wf1", "并行处理工作流", logger);

// 添加Start节点（创建并行链1）
var start1 = new WorkflowNode("start1", "采集链1", NodeType.Start);
workflow.AddNode(start1);

// 添加图像采集节点
var camera1 = new AlgorithmNode("camera1", "Camera1", NodeType.Input, "CameraCapture");
workflow.AddNode(camera1);

// 连接节点
workflow.ConnectNodes(start1.Id, camera1.Id);

// 添加Start节点（创建并行链2）
var start2 = new WorkflowNode("start2", "采集链2", NodeType.Start);
workflow.AddNode(start2);

// 添加另一个图像采集节点
var camera2 = new AlgorithmNode("camera2", "Camera2", NodeType.Input, "CameraCapture");
workflow.AddNode(camera2);

// 连接节点
workflow.ConnectNodes(start2.Id, camera2.Id);

// 添加处理节点（汇聚两条链）
var processor = new AlgorithmNode("proc1", "双图处理", NodeType.Algorithm, "DualImageProcessor");
workflow.AddNode(processor);

// 连接汇聚节点
workflow.ConnectNodes(camera1.Id, processor.Id);
workflow.ConnectNodes(camera2.Id, processor.Id);

// 执行工作流
var engine = new WorkflowExecutionEngine(workflowEngine, pluginManager, logger);
var result = await engine.ExecuteWorkflow("wf1", defaultInput);

// processor将接收到两个相机的输出：
// - 输入类型: List<object>
// - 包含: [camera1输出, camera2输出]
```

---

## 7. 性能考虑

### 7.1 并行执行优势

- **CPU利用率**：多核CPU同时执行多个链
- **I/O重叠**：不同链的I/O操作可以并行
- **执行时间**：总执行时间 ≈ max(链1时间, 链2时间, ...)

### 7.2 线程安全

- 使用 `ConcurrentDictionary<string, object>` 存储节点结果
- 无锁读取，高并发写入
- 避免 `lock` 带来的性能开销

### 7.3 内存管理

- 节点结果按需创建
- 执行完成后清理上下文
- 大量并发时注意内存峰值

---

## 8. 总结

本次优化方案的核心思想是：**简单直接，无需策略，自动并行**。

**关键点**：
1. 添加Start节点类型，明确执行链起点
2. GetNodeInput总是返回所有父节点输出
3. 基于Start节点识别执行链，实现真正的并行
4. 向后兼容，现有工作流无需修改

**优势**：
- ✅ 解决数据丢失问题
- ✅ 支持真正的并行执行
- ✅ 执行顺序清晰明确
- ✅ 逻辑简单，易于维护
- ✅ 用户无需配置复杂策略

---

## 附录

### A. 相关文件

- `SunEyeVision.Workflow/WorkflowNode.cs` - 节点类型定义
- `SunEyeVision.Workflow/Workflow.cs` - 工作流核心逻辑
- `SunEyeVision.Workflow/WorkflowExecutionEngine.cs` - 执行引擎实现

### B. 术语表

| 术语 | 说明 |
|------|------|
| 执行链 | 由Start节点驱动的独立执行单元 |
| 跨链依赖 | 不同执行链之间的节点依赖关系 |
| 拓扑排序 | 基于依赖关系确定节点执行顺序的算法 |
| 并行执行 | 多个执行链同时运行，提高执行效率 |

### C. 参考资料

- 拓扑排序算法
- Task并行编程
- 并发集合（ConcurrentDictionary）

---

*文档版本：1.0*  
*创建日期：2026-02-07*  
*作者：Claude AI Assistant*
