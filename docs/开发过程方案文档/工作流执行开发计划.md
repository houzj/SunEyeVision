# 工作流执行开发计划

## 一、概述

本文档定义了 SunEyeVision 工作流系统的完整执行优化方案，重点解决分支、循环、子程序和并行执行功能，同时简化用户操作体验。

### 核心目标
- 简化节点类型，降低用户学习成本
- 通过子程序实现复杂流程控制（循环）
- 自动检测并行执行场景
- 独立画布编辑子程序
- 完善参数映射机制

---

## 二、节点类型简化

### 2.1 节点类型定义

将复杂的节点类型简化为以下10种核心类型：

```csharp
public enum NodeType
{
    // 基础节点
    Start,           // 开始节点
    End,             // 结束节点
    Algorithm,       // 算法节点
    
    // 数据节点
    Input,           // 输入节点
    Output,          // 输出节点
    
    // 流程控制节点
    Condition,       // 条件分支节点
    Switch,          // 多路分支节点
    
    // 子程序节点
    Subroutine,      // 子程序调用节点
    SubroutineStart, // 子程序开始节点
    SubroutineEnd    // 子程序结束节点
}
```

### 2.2 节点功能说明

| 节点类型 | 功能描述 | 使用场景 |
|---------|---------|---------|
| Start | 主流程入口点 | 标识工作流的开始 |
| End | 主流程结束点 | 标识工作流的结束 |
| Algorithm | 执行具体算法 | 视觉检测、图像处理等 |
| Input | 输入数据参数 | 配置参数、图像输入等 |
| Output | 输出结果数据 | 检测结果、统计数据等 |
| Condition | 二元条件分支 | 是/否判断、阈值判断 |
| Switch | 多路条件分支 | 多个选项选择、状态判断 |
| Subroutine | 调用子程序（支持循环） | 重复执行逻辑、复杂流程封装 |
| SubroutineStart | 子程序内部入口 | 子程序画布的开始节点 |
| SubroutineEnd | 子程序内部出口 | 子程序画布的结束节点 |

---

## 三、子程序系统设计

### 3.1 核心概念

子程序是独立的工作流单元，具有以下特性：
- 在独立画布上编辑和可视化
- 支持输入/输出参数映射
- 内置循环执行能力
- 可递归调用其他子程序

### 3.2 SubroutineNode 定义

```csharp
public class SubroutineNode : WorkflowNode
{
    // 子程序基本信息
    public string SubroutineId { get; set; }           // 子程序唯一标识
    public string SubroutineName { get; set; }         // 子程序名称
    
    // 参数映射
    public List<ParameterMapping> InputMappings { get; set; }    // 输入参数映射
    public List<ParameterMapping> OutputMappings { get; set; }   // 输出参数映射
    
    // 循环配置
    public bool IsLoop { get; set; }                   // 是否启用循环
    public int MaxIterations { get; set; }            // 最大迭代次数
    public string LoopCondition { get; set; }          // 循环条件表达式
    public LoopType LoopType { get; set; }            // 循环类型
    
    // 执行统计
    public int CurrentIteration { get; set; }          // 当前迭代次数
    public TimeSpan TotalExecutionTime { get; set; }   // 总执行时间
}

public class ParameterMapping
{
    public string ExternalPortId { get; set; }        // 外部端口ID
    public string InternalPortId { get; set; }        // 子程序内部端口ID
    public string MappingName { get; set; }           // 映射名称
    public Type DataType { get; set; }                // 数据类型
}

public enum LoopType
{
    FixedCount,           // 固定次数循环
    ConditionBased,       // 条件循环（While）
    DataDriven            // 数据驱动循环（For Each）
}
```

### 3.3 子程序画布设计

#### 独立画布结构
```
主流程画布
├── Start节点
├── Algorithm节点
├── Subroutine节点（双击打开子程序画布）
│   └── 子程序画布
│       ├── SubroutineStart节点
│       ├── Input节点（参数接收）
│       ├── Algorithm节点（循环体逻辑）
│       ├── Output节点（结果返回）
│       └── SubroutineEnd节点
└── End节点
```

#### 参数边界节点
- **输入边界节点**：子程序画布的数据输入点
- **输出边界节点**：子程序画布的数据输出点
- 这些节点自动生成，用户不可删除

### 3.4 参数映射流程

```
主流程                    子程序
────────────             ────────────
[Image节点] ───┐
               ├──> Subroutine ──> [SubroutineStart]
[Config节点] ──┤                  └─> [Input边界节点] (Image)
               │                      [Input边界节点] (Config)
               │                      [Algorithm] (处理逻辑)
               │                      [Output边界节点] (Result)
               │                  └─> [SubroutineEnd]
               └──> [Result节点] <────
```

---

## 四、循环功能实现

### 4.1 循环类型

#### 类型1：固定次数循环
```
配置：IsLoop = true, LoopType = FixedCount, MaxIterations = 10
执行逻辑：重复执行子程序内容10次
```

#### 类型2：条件循环
```
配置：IsLoop = true, LoopType = ConditionBased, LoopCondition = "result.success == true"
执行逻辑：当条件满足时继续循环
```

#### 类型3：数据驱动循环
```
配置：IsLoop = true, LoopType = DataDriven
执行逻辑：对输入数据集合的每个元素执行一次
```

### 4.2 循环执行引擎

```csharp
public async Task<ExecutionResult> ExecuteSubroutineWithLoop(
    SubroutineNode subroutineNode,
    ExecutionContext context)
{
    var result = new ExecutionResult();
    var stopwatch = Stopwatch.StartNew();
    
    if (!subroutineNode.IsLoop)
    {
        // 单次执行
        return await ExecuteSubroutineOnce(subroutineNode, context);
    }
    
    // 循环执行
    for (subroutineNode.CurrentIteration = 0; 
         subroutineNode.CurrentIteration < subroutineNode.MaxIterations;
         subroutineNode.CurrentIteration++)
    {
        // 检查循环条件
        if (subroutineNode.LoopType == LoopType.ConditionBased)
        {
            if (!EvaluateLoopCondition(subroutineNode, context))
                break;
        }
        
        // 执行一次迭代
        var iterationResult = await ExecuteSubroutineOnce(subroutineNode, context);
        
        // 检查中断条件
        if (iterationResult.IsStopped)
            break;
            
        // 累加结果
        result.Merge(iterationResult);
    }
    
    stopwatch.Stop();
    subroutineNode.TotalExecutionTime = stopwatch.Elapsed;
    
    return result;
}
```

---

## 五、插件化架构设计

### 5.1 设计理念

采用插件化架构实现工作流控制功能（子程序、条件判断），通过插件机制实现功能的模块化和可扩展性。

**核心优势**：
- 功能模块化，降低耦合度
- 易于扩展新的控制节点类型
- 支持第三方插件开发
- 统一的插件加载和管理机制

### 5.2 核心接口设计

#### IWorkflowControlPlugin接口

```csharp
/// <summary>
/// 工作流控制插件接口
/// </summary>
public interface IWorkflowControlPlugin : IToolPlugin
{
    /// <summary>
    /// 获取工作流控制节点列表
    /// </summary>
    List<WorkflowControlNode> GetWorkflowControlNodes();

    /// <summary>
    /// 创建子程序节点
    /// </summary>
    SubroutineNode CreateSubroutineNode(string name, string workflowId);

    /// <summary>
    /// 创建条件判断节点
    /// </summary>
    ConditionNode CreateConditionNode(string name, string conditionExpression);

    /// <summary>
    /// 执行子程序
    /// </summary>
    Task<ExecutionResult> ExecuteSubroutine(
        SubroutineNode node,
        WorkflowContext context);

    /// <summary>
    /// 评估条件表达式
    /// </summary>
    bool EvaluateCondition(
        ConditionNode node,
        WorkflowContext context);
}
```

### 5.3 节点类型设计

#### WorkflowControlNode基类

```csharp
/// <summary>
/// 工作流控制节点基类
/// </summary>
public abstract class WorkflowControlNode : WorkflowNode
{
    /// <summary>
    /// 控制类型
    /// </summary>
    public WorkflowControlType ControlType { get; set; }

    /// <summary>
    /// 执行控制逻辑（抽象方法）
    /// </summary>
    public abstract Task<ExecutionResult> ExecuteControl(WorkflowContext context);

    /// <summary>
    /// 验证控制节点配置
    /// </summary>
    public abstract ValidationResult Validate();
}

public enum WorkflowControlType
{
    Subroutine,       // 子程序调用
    Condition,        // 条件判断
    Loop,            // 循环控制
    Switch,          // 多路分支
    TryCatch        // 异常处理
}
```

#### SubroutineNode实现

```csharp
/// <summary>
/// 子程序节点
/// </summary>
public class SubroutineNode : WorkflowControlNode
{
    public string SubroutineId { get; set; }
    public string SubroutineName { get; set; }

    // 参数映射
    public List<ParameterMapping> InputMappings { get; set; }
    public List<ParameterMapping> OutputMappings { get; set; }

    // 循环配置
    public bool IsLoop { get; set; }
    public int MaxIterations { get; set; }
    public string LoopCondition { get; set; }
    public LoopType LoopType { get; set; }

    // 执行统计
    public int CurrentIteration { get; set; }
    public TimeSpan TotalExecutionTime { get; set; }

    public SubroutineNode()
    {
        ControlType = WorkflowControlType.Subroutine;
        InputMappings = new List<ParameterMapping>();
        OutputMappings = new List<ParameterMapping>();
    }

    public override async Task<ExecutionResult> ExecuteControl(WorkflowContext context)
    {
        var plugin = context.PluginManager.GetWorkflowControlPlugin();
        return await plugin.ExecuteSubroutine(this, context);
    }

    public override ValidationResult Validate()
    {
        var result = new ValidationResult();

        if (string.IsNullOrEmpty(SubroutineId))
            result.AddError("子程序ID不能为空");

        if (IsLoop && MaxIterations <= 0)
            result.AddError("循环次数必须大于0");

        return result;
    }
}
```

#### ConditionNode实现

```csharp
/// <summary>
/// 条件判断节点
/// </summary>
public class ConditionNode : WorkflowControlNode
{
    public string ConditionExpression { get; set; }
    public string TrueBranchId { get; set; }
    public string FalseBranchId { get; set; }
    public object TrueValue { get; set; }
    public object FalseValue { get; set; }
    public bool EvaluationResult { get; private set; }

    public ConditionNode()
    {
        ControlType = WorkflowControlType.Condition;
    }

    public override async Task<ExecutionResult> ExecuteControl(WorkflowContext context)
    {
        var plugin = context.PluginManager.GetWorkflowControlPlugin();
        EvaluationResult = plugin.EvaluateCondition(this, context);

        var result = new ExecutionResult
        {
            Success = true,
            Outputs = new Dictionary<string, object>
            {
                ["result"] = EvaluationResult ? TrueValue : FalseValue,
                ["branch"] = EvaluationResult ? TrueBranchId : FalseBranchId
            }
        };

        return Task.FromResult(result);
    }

    public override ValidationResult Validate()
    {
        var result = new ValidationResult();

        if (string.IsNullOrEmpty(ConditionExpression))
            result.AddError("条件表达式不能为空");

        return result;
    }
}
```

### 5.4 执行上下文管理

#### WorkflowContext类

```csharp
/// <summary>
/// 工作流执行上下文
/// </summary>
public class WorkflowContext
{
    // 全局变量
    public Dictionary<string, object> Variables { get; set; }

    // 子程序调用栈
    public Stack<SubroutineCallInfo> CallStack { get; set; }

    // 执行路径
    public List<ExecutionPathItem> ExecutionPath { get; set; }

    // 节点执行状态
    public Dictionary<string, NodeExecutionStatus> NodeStatus { get; set; }

    // 插件管理器引用
    public IPluginManager PluginManager { get; set; }

    // 取消令牌
    public CancellationToken CancellationToken { get; set; }

    // 进度报告
    public IProgress<ExecutionProgress> ProgressReporter { get; set; }

    public WorkflowContext()
    {
        Variables = new Dictionary<string, object>();
        CallStack = new Stack<SubroutineCallInfo>();
        ExecutionPath = new List<ExecutionPathItem>();
        NodeStatus = new Dictionary<string, NodeExecutionStatus>();
    }
}

public class SubroutineCallInfo
{
    public string SubroutineId { get; set; }
    public string NodeId { get; set; }
    public int CallDepth { get; set; }
    public DateTime CallTime { get; set; }
    public Dictionary<string, object> InputParameters { get; set; }
}

public class NodeExecutionStatus
{
    public NodeStatus Status { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime? EndTime { get; set; }
    public ExecutionResult Result { get; set; }
    public List<string> ErrorMessages { get; set; }
}

public enum NodeStatus
{
    Pending,
    Running,
    Completed,
    Failed,
    Skipped
}
```

### 5.5 插件实现示例

#### SubroutinePlugin实现

```csharp
/// <summary>
/// 子程序插件实现
/// </summary>
[ToolPlugin(
    Name = "工作流控制插件",
    Version = "1.0.0",
    Description = "提供子程序调用和条件判断功能",
    Author = "SunEyeVision Team",
    Category = "WorkflowControl"
)]
public class SubroutinePlugin : IWorkflowControlPlugin
{
    private readonly IWorkflowEngine _workflowEngine;

    public SubroutinePlugin(IWorkflowEngine workflowEngine)
    {
        _workflowEngine = workflowEngine;
    }

    // IToolPlugin 接口实现
    public ToolMetadata Metadata => new ToolMetadata
    {
        Name = "工作流控制插件",
        Version = "1.0.0",
        Description = "提供子程序调用和条件判断功能",
        Category = "WorkflowControl"
    };

    public List<WorkflowControlNode> GetWorkflowControlNodes()
    {
        return new List<WorkflowControlNode>
        {
            new SubroutineNode(),
            new ConditionNode()
        };
    }

    public SubroutineNode CreateSubroutineNode(string name, string workflowId)
    {
        return new SubroutineNode
        {
            Name = name,
            SubroutineId = workflowId,
            SubroutineName = name,
            IsLoop = false,
            MaxIterations = 1
        };
    }

    public ConditionNode CreateConditionNode(string name, string conditionExpression)
    {
        return new ConditionNode
        {
            Name = name,
            ConditionExpression = conditionExpression,
            TrueValue = true,
            FalseValue = false
        };
    }

    public async Task<ExecutionResult> ExecuteSubroutine(
        SubroutineNode node,
        WorkflowContext context)
    {
        var result = new ExecutionResult();
        var stopwatch = Stopwatch.StartNew();

        try
        {
            // 记录调用信息
            context.CallStack.Push(new SubroutineCallInfo
            {
                SubroutineId = node.SubroutineId,
                NodeId = node.Id,
                CallDepth = context.CallStack.Count,
                CallTime = DateTime.Now,
                InputParameters = MapInputParameters(node, context)
            });

            // 获取子程序工作流
            var subroutineWorkflow = _workflowEngine.GetWorkflow(node.SubroutineId);
            if (subroutineWorkflow == null)
            {
                result.AddError($"子程序 {node.SubroutineId} 不存在");
                return result;
            }

            // 执行子程序
            if (!node.IsLoop)
            {
                // 单次执行
                var execResult = await _workflowEngine.ExecuteAsync(
                    subroutineWorkflow,
                    context);
                result.Merge(execResult);
            }
            else
            {
                // 循环执行
                result = await ExecuteSubroutineWithLoop(node, subroutineWorkflow, context);
            }

            // 映射输出参数
            MapOutputParameters(node, result, context);

            // 记录执行路径
            context.ExecutionPath.Add(new ExecutionPathItem
            {
                NodeId = node.Id,
                NodeType = "Subroutine",
                Timestamp = DateTime.Now,
                Duration = stopwatch.Elapsed,
                Success = result.Success
            });
        }
        catch (Exception ex)
        {
            result.AddError($"子程序执行失败: {ex.Message}");
        }
        finally
        {
            stopwatch.Stop();
            result.ExecutionTime = stopwatch.Elapsed;
            context.CallStack.Pop();
        }

        return result;
    }

    public bool EvaluateCondition(ConditionNode node, WorkflowContext context)
    {
        // 简单的条件表达式解析器
        var expression = node.ConditionExpression;

        // 替换变量
        foreach (var variable in context.Variables)
        {
            expression = expression.Replace($"${variable.Key}", variable.Value?.ToString() ?? "null");
        }

        // 使用动态编译评估表达式
        // 实际实现应该使用更安全的表达式解析器
        try
        {
            // 简化示例：只支持简单的比较表达式
            // 生产环境应该使用System.Linq.Expressions或第三方表达式解析器
            return EvaluateSimpleExpression(expression);
        }
        catch
        {
            return false;
        }
    }

    private async Task<ExecutionResult> ExecuteSubroutineWithLoop(
        SubroutineNode node,
        Workflow subroutineWorkflow,
        WorkflowContext context)
    {
        var result = new ExecutionResult();

        for (node.CurrentIteration = 0;
             node.CurrentIteration < node.MaxIterations;
             node.CurrentIteration++)
        {
            // 检查循环条件
            if (node.LoopType == LoopType.ConditionBased)
            {
                if (!EvaluateLoopCondition(node, context))
                    break;
            }

            // 检查取消令牌
            context.CancellationToken.ThrowIfCancellationRequested();

            // 执行一次迭代
            var iterationResult = await _workflowEngine.ExecuteAsync(
                subroutineWorkflow,
                context);

            if (!iterationResult.Success)
            {
                result.AddError($"循环第 {node.CurrentIteration + 1} 次迭代失败");
                break;
            }

            result.Merge(iterationResult);

            // 报告进度
            context.ProgressReporter?.Report(new ExecutionProgress
            {
                CurrentIteration = node.CurrentIteration + 1,
                TotalIterations = node.MaxIterations,
                Message = $"执行循环迭代 {node.CurrentIteration + 1}/{node.MaxIterations}"
            });
        }

        node.TotalExecutionTime = result.ExecutionTime;
        return result;
    }

    private Dictionary<string, object> MapInputParameters(
        SubroutineNode node,
        WorkflowContext context)
    {
        var parameters = new Dictionary<string, object>();

        foreach (var mapping in node.InputMappings)
        {
            if (context.Variables.TryGetValue(mapping.ExternalPortId, out var value))
            {
                parameters[mapping.InternalPortId] = value;
            }
        }

        return parameters;
    }

    private void MapOutputParameters(
        SubroutineNode node,
        ExecutionResult result,
        WorkflowContext context)
    {
        foreach (var mapping in node.OutputMappings)
        {
            if (result.Outputs.TryGetValue(mapping.InternalPortId, out var value))
            {
                context.Variables[mapping.ExternalPortId] = value;
            }
        }
    }

    private bool EvaluateSimpleExpression(string expression)
    {
        // 简化实现，生产环境应使用完整的表达式解析器
        // 这里仅作为示例
        return true;
    }

    private bool EvaluateLoopCondition(SubroutineNode node, WorkflowContext context)
    {
        var expression = node.LoopCondition;

        foreach (var variable in context.Variables)
        {
            expression = expression.Replace($"${variable.Key}", variable.Value?.ToString() ?? "null");
        }

        return EvaluateSimpleExpression(expression);
    }
}
```

### 5.6 工作流引擎扩展

#### WorkflowEngine扩展方法

```csharp
public partial class WorkflowEngine
{
    private readonly IPluginManager _pluginManager;

    public WorkflowEngine(IPluginManager pluginManager)
    {
        _pluginManager = pluginManager;
    }

    // 执行工作流控制节点
    private async Task<ExecutionResult> ExecuteWorkflowControlNode(
        WorkflowControlNode node,
        WorkflowContext context)
    {
        // 更新节点状态为运行中
        context.NodeStatus[node.Id] = new NodeExecutionStatus
        {
            Status = NodeStatus.Running,
            StartTime = DateTime.Now
        };

        try
        {
            // 执行控制逻辑
            var result = await node.ExecuteControl(context);

            // 更新节点状态为完成
            context.NodeStatus[node.Id].Status = NodeStatus.Completed;
            context.NodeStatus[node.Id].EndTime = DateTime.Now;
            context.NodeStatus[node.Id].Result = result;

            return result;
        }
        catch (Exception ex)
        {
            context.NodeStatus[node.Id].Status = NodeStatus.Failed;
            context.NodeStatus[node.Id].EndTime = DateTime.Now;
            context.NodeStatus[node.Id].ErrorMessages = new List<string> { ex.Message };

            return new ExecutionResult
            {
                Success = false,
                Errors = new List<ExecutionError>
                {
                    new ExecutionError
                    {
                        NodeId = node.Id,
                        Message = ex.Message,
                        StackTrace = ex.StackTrace
                    }
                }
            };
        }
    }

    // 获取所有工作流控制插件
    public List<IWorkflowControlPlugin> GetWorkflowControlPlugins()
    {
        return _pluginManager.GetPlugins<IWorkflowControlPlugin>();
    }

    // 获取所有可用的控制节点类型
    public List<WorkflowControlNode> GetAvailableControlNodes()
    {
        var plugins = GetWorkflowControlPlugins();
        var nodes = new List<WorkflowControlNode>();

        foreach (var plugin in plugins)
        {
            nodes.AddRange(plugin.GetWorkflowControlNodes());
        }

        return nodes;
    }
}
```

### 5.7 UI层集成

#### ToolboxViewModel扩展

```csharp
public partial class ToolboxViewModel
{
    private void LoadWorkflowControlPlugins()
    {
        var plugins = _workflowEngine.GetWorkflowControlPlugins();

        foreach (var plugin in plugins)
        {
            var category = new ToolboxCategory(plugin.Metadata.Category);
            var nodes = plugin.GetWorkflowControlNodes();

            foreach (var node in nodes)
            {
                category.Items.Add(new ToolboxItem
                {
                    Name = node.Name,
                    Type = node.GetType(),
                    Icon = GetIconForNodeType(node.ControlType),
                    Description = GetDescriptionForNodeType(node.ControlType),
                    DragData = new WorkflowNodeCreationData
                    {
                        NodeType = node.ControlType,
                        PluginName = plugin.Metadata.Name
                    }
                });
            }

            Categories.Add(category);
        }
    }

    private string GetIconForNodeType(WorkflowControlType type)
    {
        switch (type)
        {
            case WorkflowControlType.Subroutine:
                return "SubroutineIcon";
            case WorkflowControlType.Condition:
                return "ConditionIcon";
            case WorkflowControlType.Loop:
                return "LoopIcon";
            case WorkflowControlType.Switch:
                return "SwitchIcon";
            case WorkflowControlType.TryCatch:
                return "TryCatchIcon";
            default:
                return "DefaultIcon";
        }
    }

    private string GetDescriptionForNodeType(WorkflowControlType type)
    {
        switch (type)
        {
            case WorkflowControlType.Subroutine:
                return "调用子程序工作流，支持循环执行";
            case WorkflowControlType.Condition:
                return "根据条件表达式进行分支判断";
            case WorkflowControlType.Loop:
                return "循环执行指定节点";
            case WorkflowControlType.Switch:
                return "多路条件分支";
            case WorkflowControlType.TryCatch:
                return "异常捕获和处理";
            default:
                return "工作流控制节点";
        }
    }
}
```

### 5.8 实施阶段

#### 阶段一：接口和基础类（1周）

**任务清单**：
1. ⬜ 定义IWorkflowControlPlugin接口
2. ⬜ 实现WorkflowControlNode基类
3. ⬜ 实现SubroutineNode类
4. ⬜ 实现ConditionNode类
5. ⬜ 实现WorkflowContext类

**验收标准**：
- 接口定义完整
- 基础类可编译通过
- 单元测试通过

#### 阶段二：插件实现（1-2周）

**任务清单**：
1. ⬜ 实现SubroutinePlugin类
2. ⬜ 实现子程序执行逻辑
3. ⬜ 实现条件评估逻辑
4. ⬜ 实现参数映射机制
5. ⬜ 集成到PluginLoader

**验收标准**：
- 插件可以正常加载
- 子程序可以正确执行
- 条件判断可以正确评估

#### 阶段三：工作流引擎扩展（1周）

**任务清单**：
1. ⬜ 扩展WorkflowEngine支持控制节点
2. ⬜ 实现调用栈管理
3. ⬜ 实现节点状态追踪
4. ⬜ 实现错误处理机制
5. ⬜ 集成测试

**验收标准**：
- 工作流引擎可以执行控制节点
- 调用栈正确维护
- 状态追踪准确

#### 阶段四：UI集成（1周）

**任务清单**：
1. ⬜ 扩展ToolboxViewModel
2. ⬜ 实现控制节点创建
3. ⬜ 实现参数映射UI
4. ⬜ 实现子程序编辑器
5. ⬜ 用户体验优化

**验收标准**：
- 用户可以从工具箱创建控制节点
- 参数映射界面易用
- 子程序编辑流畅

#### 阶段五：测试和优化（1周）

**任务清单**：
1. ⬜ 单元测试覆盖
2. ⬜ 集成测试验证
3. ⬜ 性能测试
4. ⬜ 文档更新
5. ⬜ 用户培训材料

**验收标准**：
- 测试覆盖率>80%
- 性能满足要求
- 文档完整

### 5.9 优势总结

**插件化架构的核心优势**：

1. **模块化**：子程序和条件判断功能完全独立，降低耦合度
2. **可扩展**：易于添加新的控制节点类型（如TryCatch、Switch等）
3. **可维护**：插件代码独立，便于维护和升级
4. **可复用**：插件可以在不同项目中复用
5. **标准化**：统一的插件接口，便于第三方开发
6. **灵活加载**：支持运行时动态加载插件

**与传统硬编码实现对比**：

| 对比项 | 插件化方案 | 硬编码方案 |
|--------|-----------|-----------|
| 扩展性 | ★★★★★ | ★★☆☆☆ |
| 维护性 | ★★★★★ | ★★★☆☆ |
| 可测试性 | ★★★★★ | ★★★☆☆ |
| 灵活性 | ★★★★★ | ★★☆☆☆ |
| 实现复杂度 | ★★★☆☆ | ★★★★★ |
| 性能 | ★★★★☆ | ★★★★★ |

---

## 六、并行执行检测

### 5.1 核心原理

通过分析节点依赖关系图（DAG），自动识别可并行执行的节点组。

**关键原则**：
- 无依赖关系的节点可以并行执行
- 有依赖关系的节点必须串行执行
- 通过连接线（Edges）自动推导依赖关系

### 5.2 依赖关系分析

```csharp
public class WorkflowEngine
{
    // 分析节点依赖关系
    public List<List<WorkflowNode>> AnalyzeDependencies(Workflow workflow)
    {
        var nodes = workflow.Nodes;
        var edges = workflow.Connections;
        
        // 构建依赖图
        var graph = BuildDependencyGraph(nodes, edges);
        
        // 拓扑排序并识别可并行层
        var parallelGroups = IdentifyParallelGroups(graph);
        
        return parallelGroups;
    }
    
    private List<List<WorkflowNode>> IdentifyParallelGroups(
        Dictionary<WorkflowNode, List<WorkflowNode>> graph)
    {
        var result = new List<List<WorkflowNode>>();
        var executed = new HashSet<WorkflowNode>();
        var remaining = new HashSet<WorkflowNode>(graph.Keys);
        
        while (remaining.Count > 0)
        {
            // 找出所有入度为0的节点（无依赖）
            var readyNodes = remaining.Where(n => 
                executed.ContainsAll(graph[n])).ToList();
            
            if (readyNodes.Count == 0)
                throw new InvalidOperationException("检测到循环依赖");
            
            // 这些节点可以并行执行
            result.Add(readyNodes);
            
            // 标记为已执行
            foreach (var node in readyNodes)
            {
                executed.Add(node);
                remaining.Remove(node);
            }
        }
        
        return result;
    }
}
```

### 5.3 并行执行示例

```
并行组1（无依赖）：  [Input1] [Input2] [Config]
       ↓            ↓         ↓
并行组2（等待输入完成）：  [Preprocess1] [Preprocess2]
       ↓            ↓
并行组3（等待预处理完成）：[Algorithm] [FeatureExtraction]
       ↓            ↓
并行组4（合并结果）：    [Postprocess]
       ↓
并行组5（最终输出）：    [Output]
```

---

## 七、执行引擎架构

### 7.1 执行流程

```
1. 工作流启动
   ↓
2. 参数初始化
   ↓
3. 依赖关系分析（识别并行组）
   ↓
4. 按并行组顺序执行
   ├─ 并行组N启动
   │  ├─ 节点1执行（异步）
   │  ├─ 节点2执行（异步）
   │  └─ 节点3执行（异步）
   │  ↓
   │  等待所有节点完成
   ↓
5. 子程序调用（检测到Subroutine节点）
   ├─ 参数映射
   ├─ 循环控制（如果IsLoop=true）
   │  └─ 迭代执行子程序内容
   └─ 结果返回
   ↓
6. 结果聚合
   ↓
7. 工作流结束
```

### 7.2 核心类设计

```csharp
// 执行上下文
public class ExecutionContext
{
    public Dictionary<string, object> Variables { get; set; }
    public CancellationToken CancellationToken { get; set; }
    public IProgress<ExecutionProgress> ProgressReporter { get; set; }
    public List<ExecutionLog> Logs { get; set; }
}

// 执行结果
public class ExecutionResult
{
    public bool Success { get; set; }
    public Dictionary<string, object> Outputs { get; set; }
    public List<ExecutionError> Errors { get; set; }
    public TimeSpan ExecutionTime { get; set; }
    public bool IsStopped { get; set; }
}

// 执行引擎
public class WorkflowEngine
{
    public async Task<ExecutionResult> ExecuteAsync(
        Workflow workflow,
        ExecutionContext context);
    
    private async Task<ExecutionResult> ExecuteParallelGroup(
        List<WorkflowNode> nodes,
        ExecutionContext context);
    
    private async Task<ExecutionResult> ExecuteSubroutine(
        SubroutineNode node,
        ExecutionContext context);
}
```

---

## 八、UI层优化

### 8.1 节点工厂简化

```csharp
public class WorkflowNodeFactory
{
    public WorkflowNode CreateNode(NodeType type)
    {
        switch (type)
        {
            case NodeType.Algorithm:
                return new AlgorithmNode();
            case NodeType.Subroutine:
                return new SubroutineNode
                {
                    IsLoop = false,
                    MaxIterations = 1
                };
            case NodeType.Condition:
                return new ConditionNode();
            case NodeType.Switch:
                return new SwitchNode();
            // ... 其他节点类型
            default:
                throw new NotSupportedException($"不支持节点类型: {type}");
        }
    }
}
```

### 8.2 子程序编辑器

#### 打开子程序画布
```csharp
public void OpenSubroutineEditor(SubroutineNode subroutineNode)
{
    // 查找或创建子程序工作流
    var subroutineWorkflow = _workflowService
        .GetOrCreateSubroutine(subroutineNode.SubroutineId);
    
    // 打开新的标签页
    _tabService.OpenTab(
        new WorkflowTabViewModel(subroutineWorkflow));
}
```

#### 参数映射界面
```csharp
public class SubroutineParameterMappingViewModel
{
    // 输入参数映射
    public ObservableCollection<ParameterMappingViewModel> InputMappings { get; }
    
    // 输出参数映射
    public ObservableCollection<ParameterMappingViewModel> OutputMappings { get; }
    
    // 循环配置
    public bool IsLoop { get; set; }
    public int MaxIterations { get; set; }
    public LoopType LoopType { get; set; }
    public string LoopCondition { get; set; }
}
```

### 8.3 执行状态可视化

#### 节点状态指示器
- **灰色**：未执行
- **蓝色**：执行中
- **绿色**：执行成功
- **红色**：执行失败
- **黄色**：循环中（Subroutine节点）

#### 进度条显示
- 显示当前执行进度
- 显示并行节点执行情况
- 显示循环迭代次数

---

## 九、实施计划

### 阶段一：核心架构（1-2周）

**任务清单**：
1. ✅ 简化NodeType枚举
2. ✅ 实现SubroutineNode核心类
3. ✅ 实现ParameterMapping模型
4. ✅ 设计子程序画布结构
5. ✅ 实现参数映射机制

**验收标准**：
- 节点类型精简到10种
- Subroutine节点支持基本参数映射
- 子程序可以在独立画布打开

### 阶段二：循环功能（1周）

**任务清单**：
1. ⬜ 实现三种循环类型
2. ⬜ 集成循环执行引擎
3. ⬜ 添加循环条件评估器
4. ⬜ 实现循环次数限制
5. ⬜ 添加循环进度显示

**验收标准**：
- Subroutine节点可以配置为循环
- 支持固定次数、条件、数据驱动三种循环
- 循环可以正确中断和终止

### 阶段三：并行执行（1-2周）

**任务清单**：
1. ⬜ 实现依赖关系分析器
2. ⬜ 实现拓扑排序算法
3. ⬜ 实现并行组识别
4. ⬜ 集成并行执行引擎
5. ⬜ 添加并行执行可视化

**验收标准**：
- 自动识别可并行节点
- 并行执行正确且高效
- 可以在UI中看到并行组执行情况

### 阶段四：UI优化（1周）

**任务清单**：
1. ⬜ 实现子程序编辑器
2. ⬜ 实现参数映射界面
3. ⬜ 优化节点状态显示
4. ⬜ 添加执行进度条
5. ⬜ 改进用户体验

**验收标准**：
- 子程序编辑流畅易用
- 参数映射直观清晰
- 执行状态实时可见

### 阶段五：测试与优化（1周）

**任务清单**：
1. ⬜ 单元测试覆盖
2. ⬜ 集成测试验证
3. ⬜ 性能测试与优化
4. ⬜ 文档更新
5. ⬜ 用户培训材料

**验收标准**：
- 测试覆盖率>80%
- 性能满足要求
- 文档完整准确

---

## 十、技术风险与应对

### 10.1 主要风险

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|---------|
| 循环依赖导致死锁 | 高 | 中 | 实现循环检测算法，提前发现并报错 |
| 子程序递归过深 | 中 | 低 | 设置最大递归深度限制 |
| 并行执行资源竞争 | 高 | 中 | 使用线程安全的数据结构，加锁保护 |
| 参数映射复杂度高 | 中 | 中 | 提供图形化配置界面，降低使用难度 |

### 10.2 性能优化策略

1. **并行执行**：充分利用多核CPU，通过Task.WhenAll并行执行无依赖节点
2. **缓存优化**：缓存子程序执行结果，避免重复计算
3. **懒加载**：子程序画布按需加载，减少内存占用
4. **增量执行**：支持从断点继续执行，避免重复工作

---

## 十一、成功指标

### 11.1 用户体验指标

- 节点类型从15+减少到10个
- 创建子程序操作<3步
- 参数配置时间<30秒
- 学习时间<1小时

### 11.2 技术指标

- 并行执行性能提升>50%
- 工作流执行时间减少>30%
- 循环执行准确率100%
- 内存占用增加<20%

### 11.3 功能完整性

- ✅ 支持所有基础节点类型
- ✅ 子程序支持三种循环模式
- ✅ 自动检测并行执行
- ✅ 完整的参数映射机制
- ✅ 独立的子程序编辑画布

---

## 十二、后续扩展

### 12.1 短期扩展（1-2月）

- 支持子程序版本管理
- 实现子程序模板库
- 添加执行断点调试
- 支持条件断点

### 12.2 中期扩展（3-6月）

- 实现子程序云端同步
- 支持子程序共享市场
- 添加AI辅助设计
- 实现可视化调试器

### 12.3 长期规划（6月+）

- 支持分布式执行
- 实现跨设备协作
- 集成机器学习优化
- 构建生态系统

---

## 十三、总结

本方案通过简化节点类型、强化子程序功能、自动检测并行执行，大幅提升了工作流系统的易用性和性能。核心创新点包括：

1. **节点简化**：从15+减少到10种，降低学习成本
2. **子程序增强**：独立画布编辑 + 内置循环功能
3. **智能并行**：自动分析依赖关系，无需用户手动配置
4. **参数映射**：图形化配置，直观易用

预计实施周期：5-6周
预期性能提升：50%+
用户体验改善：显著提升

---

**文档版本**：v1.0  
**创建日期**：2026-02-06  
**负责人**：SunEyeVision开发团队  
**状态**：待实施
