#include "pch.h"
#include "LibavoidWrapper.h"
#include <algorithm>
#include <cmath>

using namespace System;
using namespace System::Diagnostics;

namespace SunEyeVision {

    namespace LibavoidWrapper {

        // Constructor
        LibavoidRouter::LibavoidRouter()
        {
            config = gcnew RouterConfiguration();
            cachedResults = gcnew List<RoutingResult^>();
        }

        // Constructor with configuration
        LibavoidRouter::LibavoidRouter(RouterConfiguration^ configuration)
        {
            config = configuration;
            cachedResults = gcnew List<RoutingResult^>();
        }

        // Destructor
        LibavoidRouter::~LibavoidRouter()
        {
            this->!LibavoidRouter();
        }

        // Finalizer
        LibavoidRouter::!LibavoidRouter()
        {
            if (cachedResults != nullptr)
            {
                cachedResults->Clear();
            }
        }

        // Check if point is in rectangle
        bool LibavoidRouter::PointInRect(ManagedPoint point, ManagedRect rect)
        {
            return point.X >= rect.Left && point.X <= rect.Right &&
                   point.Y >= rect.Top && point.Y <= rect.Bottom;
        }

        // Check if line segment intersects rectangle
        bool LibavoidRouter::LineIntersectsRect(ManagedPoint p1, ManagedPoint p2, ManagedRect rect)
        {
            // Check if endpoints are in rectangle
            if (PointInRect(p1, rect) || PointInRect(p2, rect))
            {
                return true;
            }

            // Check if line segment intersects rectangle's edges
            double minX = (p1.X < p2.X) ? p1.X : p2.X;
            double maxX = (p1.X > p2.X) ? p1.X : p2.X;
            double minY = (p1.Y < p2.Y) ? p1.Y : p2.Y;
            double maxY = (p1.Y > p2.Y) ? p1.Y : p2.Y;

            // Rectangle's four edges
            if (minX <= rect.Right && maxX >= rect.Left &&
                minY <= rect.Bottom && maxY >= rect.Top)
            {
                return true;
            }

            return false;
        }

        // Get port position
        ManagedPoint LibavoidRouter::GetPortPosition(ManagedRect rect, PortDirection direction)
        {
            switch (direction)
            {
            case PortDirection::Top:
                return ManagedPoint(rect.X + rect.Width / 2, rect.Y);
            case PortDirection::Bottom:
                return ManagedPoint(rect.X + rect.Width / 2, rect.Y + rect.Height);
            case PortDirection::Left:
                return ManagedPoint(rect.X, rect.Y + rect.Height / 2);
            case PortDirection::Right:
                return ManagedPoint(rect.X + rect.Width, rect.Y + rect.Height / 2);
            default:
                return ManagedPoint(rect.X + rect.Width / 2, rect.Y + rect.Height / 2);
            }
        }

        // Adjust point for direction
        // Note: This method is no longer used by RoutePath, which now uses
        // positions directly calculated by the caller (ConnectionPathCache)
        ManagedPoint LibavoidRouter::AdjustPointForDirection(ManagedPoint point, PortDirection direction, double offset)
        {
            switch (direction)
            {
            case PortDirection::Top:
                return ManagedPoint(point.X, point.Y - offset);
            case PortDirection::Bottom:
                return ManagedPoint(point.X, point.Y + offset);
            case PortDirection::Left:
                return ManagedPoint(point.X - offset, point.Y);
            case PortDirection::Right:
                return ManagedPoint(point.X + offset, point.Y);
            default:
                return point;
            }
        }

        // Check if path intersects obstacles
        bool LibavoidRouter::PathIntersectsObstacles(List<ManagedPoint>^ path, List<ManagedRect>^ obstacles)
        {
            if (path == nullptr || path->Count < 2 || obstacles == nullptr)
            {
                return false;
            }

            int pathCount = path->Count;
            for (int i = 0; i < pathCount - 1; i++)
            {
                ManagedPoint p1 = path[i];
                ManagedPoint p2 = path[i + 1];

                int obstacleCount = obstacles->Count;
                for (int j = 0; j < obstacleCount; j++)
                {
                    ManagedRect obstacle = obstacles[j];
                    if (LineIntersectsRect(p1, p2, obstacle))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        // Calculate orthogonal path (internal implementation)
        List<ManagedPoint>^ LibavoidRouter::CalculateOrthogonalPathInternal(
            ManagedPoint source,
            ManagedPoint target,
            PortDirection sourceDir,
            PortDirection targetDir,
            List<ManagedRect>^ obstacles)
        {
            List<ManagedPoint>^ path = gcnew List<ManagedPoint>();
            
            // DEBUG: Log input parameters
            Debug::WriteLine(
                String::Format("[LibavoidCpp] CalculateOrthogonalPathInternal - Source:({0:F1},{1:F1}), Target:({2:F1},{3:F1})",
                source.X, source.Y, target.X, target.Y));

            // Add source point as-is (no adjustment)
            Debug::WriteLine(String::Format(
                "[LibavoidCpp] Adding source point to path: ({0:F1},{1:F1})", source.X, source.Y));
            path->Add(source);
            Debug::WriteLine(String::Format(
                "[LibavoidCpp] Path[0] after add: ({0:F1},{1:F1})", path[0].X, path[0].Y));

            // Choose path strategy based on source and target directions
            bool horizontalFirst = false;

            if (sourceDir == PortDirection::Left || sourceDir == PortDirection::Right)
            {
                horizontalFirst = true;
            }
            else if (sourceDir == PortDirection::Top || sourceDir == PortDirection::Bottom)
            {
                horizontalFirst = false;
            }
            else if (targetDir == PortDirection::Left || targetDir == PortDirection::Right)
            {
                horizontalFirst = true;
            }
            else if (targetDir == PortDirection::Top || targetDir == PortDirection::Bottom)
            {
                horizontalFirst = false;
            }
            else
            {
                // Default strategy: based on relative position
                double dx = (target.X - source.X);
                double dy = (target.Y - source.Y);
                if (dx < 0) dx = -dx;
                if (dy < 0) dy = -dy;
                horizontalFirst = dx > dy;
            }

            // Three-segment path calculation
            if (horizontalFirst)
            {
                // Horizontal first: source -> middle1 -> middle2 -> target
                double midX = (source.X + target.X) / 2;
                ManagedPoint mid1;
                mid1.X = midX;
                mid1.Y = source.Y;
                ManagedPoint mid2;
                mid2.X = midX;
                mid2.Y = target.Y;

                path->Add(mid1);
                path->Add(mid2);
            }
            else
            {
                // Vertical first: source -> middle1 -> middle2 -> target
                double midY = (source.Y + target.Y) / 2;
                ManagedPoint mid1;
                mid1.X = source.X;
                mid1.Y = midY;
                ManagedPoint mid2;
                mid2.X = target.X;
                mid2.Y = midY;

                path->Add(mid1);
                path->Add(mid2);
            }

            // Add target point as-is (no adjustment)
            Debug::WriteLine(String::Format(
                "[LibavoidCpp] Adding target point to path: ({0:F1},{1:F1})", target.X, target.Y));
            path->Add(target);
            Debug::WriteLine(String::Format(
                "[LibavoidCpp] Path[last] after add: ({0:F1},{1:F1}), Index={2}",
                path[path->Count-1].X, path[path->Count-1].Y, path->Count-1));

            // DEBUG: Log all path points
            Debug::WriteLine(String::Format("[LibavoidCpp] Final path has {0} points:", path->Count));
            for (int i = 0; i < path->Count; i++)
            {
                Debug::WriteLine(String::Format(
                    "[LibavoidCpp]   Path[{0}]: ({1:F1},{2:F1})", i, path[i].X, path[i].Y));
            }

            // DEBUG: Log path points
            Debug::WriteLine(String::Format("[LibavoidCpp] Path points count: {0}", path->Count));
            for (int i = 0; i < path->Count; i++)
            {
                Debug::WriteLine(
                    String::Format("[LibavoidCpp]   Point[{0}]:({1:F1},{2:F1})",
                    i, path[i].X, path[i].Y));
            }

            return path;
        }

        // Apply node avoidance
        // Important: Never modify the first and last points to ensure accurate start/end positions
        List<ManagedPoint>^ LibavoidRouter::ApplyNodeAvoidance(
            List<ManagedPoint>^ path,
            List<ManagedRect>^ obstacles)
        {
            if (path == nullptr || path->Count < 2 || obstacles == nullptr || obstacles->Count == 0)
            {
                return path;
            }

            List<ManagedPoint>^ newPath = gcnew List<ManagedPoint>(path);
            int maxIterations = 5;
            int iteration = 0;
            bool hasCollision = true;

            while (hasCollision && iteration < maxIterations)
            {
                hasCollision = false;
                iteration++;

                int pathCount = newPath->Count;

                // Skip the first and last segments to preserve start and end points
                for (int i = 1; i < pathCount - 2; i++)
                {
                    ManagedPoint p1 = newPath[i];
                    ManagedPoint p2 = newPath[i + 1];

                    int obstacleCount = obstacles->Count;
                    for (int j = 0; j < obstacleCount; j++)
                    {
                        ManagedRect obstacle = obstacles[j];
                        if (LineIntersectsRect(p1, p2, obstacle))
                        {
                            hasCollision = true;

                            // Calculate avoidance point
                            double offsetX = obstacle.Width / 2 + 10;
                            double offsetY = obstacle.Height / 2 + 10;

                            // Choose avoidance direction
                            double dx = p2.X - p1.X;
                            double dy = p2.Y - p1.Y;

                            double absDx = (dx < 0) ? -dx : dx;
                            double absDy = (dy < 0) ? -dy : dy;

                            ManagedPoint avoidPoint;
                            if (absDx > absDy)
                            {
                                // Horizontal line, avoid vertically
                                if (p1.Y < obstacle.Top)
                                {
                                    avoidPoint = ManagedPoint((p1.X + p2.X) / 2, obstacle.Top - offsetY);
                                }
                                else
                                {
                                    avoidPoint = ManagedPoint((p1.X + p2.X) / 2, obstacle.Bottom + offsetY);
                                }
                            }
                            else
                            {
                                // Vertical line, avoid horizontally
                                if (p1.X < obstacle.Left)
                                {
                                    avoidPoint = ManagedPoint(obstacle.Left - offsetX, (p1.Y + p2.Y) / 2);
                                }
                                else
                                {
                                    avoidPoint = ManagedPoint(obstacle.Right + offsetX, (p1.Y + p2.Y) / 2);
                                }
                            }

                            // Insert avoidance point
                            newPath->Insert(i + 1, avoidPoint);
                            i++; // Skip newly inserted point
                            break;
                        }
                    }
                }
            }

            return newPath;
        }

        // Route single path
        RoutingResult^ LibavoidRouter::RoutePath(
            ManagedPoint source,
            ManagedPoint target,
            PortDirection sourceDirection,
            PortDirection targetDirection,
            ManagedRect sourceRect,
            ManagedRect targetRect,
            List<ManagedRect>^ obstacles)
        {
            RoutingResult^ result = gcnew RoutingResult();

            try
            {
                // DEBUG: Log input parameters
                Debug::WriteLine(String::Format(
                    "[LibavoidCpp RoutePath] Input - Source:({0:F1},{1:F1}), Target:({2:F1},{3:F1})",
                    source.X, source.Y, target.X, target.Y));

                // Use the provided source and target positions directly
                // These positions are already correctly calculated by the caller:
                // - source: source port position (path start)
                // - target: arrow tail position (path end)
                ManagedPoint adjustedSource = source;
                ManagedPoint adjustedTarget = target;

                // DEBUG: Log after assignment
                Debug::WriteLine(String::Format(
                    "[LibavoidCpp RoutePath] After assignment - Source:({0:F1},{1:F1}), Target:({2:F1},{3:F1})",
                    adjustedSource.X, adjustedSource.Y, adjustedTarget.X, adjustedTarget.Y));

                // Filter out source and target rects from obstacles
                // to prevent adjustments to start/end points
                List<ManagedRect>^ filteredObstacles = gcnew List<ManagedRect>();
                if (obstacles != nullptr && obstacles->Count > 0)
                {
                    Debug::WriteLine(String::Format(
                        "[LibavoidCpp] Start filtering obstacles, total count: {0}", obstacles->Count));
                    
                    for each (ManagedRect obstacle in obstacles)
                    {
                        // Check if this is the source rect (with small tolerance for floating point comparison)
                        bool isSource = (Math::Abs(obstacle.Left - sourceRect.Left) < 0.1 &&
                                        Math::Abs(obstacle.Top - sourceRect.Top) < 0.1 &&
                                        Math::Abs(obstacle.Right - sourceRect.Right) < 0.1 &&
                                        Math::Abs(obstacle.Bottom - sourceRect.Bottom) < 0.1);
                        
                        // Check if this is the target rect
                        bool isTarget = (Math::Abs(obstacle.Left - targetRect.Left) < 0.1 &&
                                        Math::Abs(obstacle.Top - targetRect.Top) < 0.1 &&
                                        Math::Abs(obstacle.Right - targetRect.Right) < 0.1 &&
                                        Math::Abs(obstacle.Bottom - targetRect.Bottom) < 0.1);
                        
                        Debug::WriteLine(String::Format(
                            "[LibavoidCpp] Check obstacle: Left={0:F1},Top={1:F1},Right={2:F1},Bottom={3:F1}, IsSource={4}, IsTarget={5}",
                            obstacle.Left, obstacle.Top, obstacle.Right, obstacle.Bottom, isSource, isTarget));
                        
                        // Only add obstacles that are NOT source or target
                        if (!isSource && !isTarget)
                        {
                            filteredObstacles->Add(obstacle);
                        }
                    }
                    
                    Debug::WriteLine(String::Format(
                        "[LibavoidCpp] Filtered obstacles count: {0}", filteredObstacles->Count));
                }

                // Calculate initial path
                List<ManagedPoint>^ path = CalculateOrthogonalPathInternal(
                    adjustedSource,
                    adjustedTarget,
                    sourceDirection,
                    targetDirection,
                    filteredObstacles);

                Debug::WriteLine(String::Format(
                    "[LibavoidCpp RoutePath] Path returned from CalculateOrthogonalPathInternal: {0} points", path->Count));
                for (int i = 0; i < path->Count; i++)
                {
                    Debug::WriteLine(String::Format(
                        "[LibavoidCpp RoutePath]   Path[{0}]: ({1:F1},{2:F1})", i, path[i].X, path[i].Y));
                }

                // Apply node avoidance
                if (filteredObstacles != nullptr && filteredObstacles->Count > 0)
                {
                    Debug::WriteLine(String::Format("[LibavoidCpp RoutePath] Calling ApplyNodeAvoidance..."));
                    path = ApplyNodeAvoidance(path, filteredObstacles);
                    Debug::WriteLine(String::Format(
                        "[LibavoidCpp RoutePath] Path after ApplyNodeAvoidance: {0} points", path->Count));
                    for (int i = 0; i < path->Count; i++)
                    {
                        Debug::WriteLine(String::Format(
                            "[LibavoidCpp RoutePath]   Path[{0}]: ({1:F1},{2:F1})", i, path[i].X, path[i].Y));
                    }
                }

                // Check if path still intersects obstacles (use filtered obstacles)
                if (PathIntersectsObstacles(path, filteredObstacles))
                {
                    result->ErrorMessage = "Path still intersects obstacles";
                }

                // Set result
                result->PathPoints = path;
                result->Success = true;
                result->Iterations = 1;

                // Cache result
                cachedResults->Add(result);
            }
            catch (Exception^ ex)
            {
                result->Success = false;
                result->ErrorMessage = ex->Message;
            }

            return result;
        }

        // Batch route multiple paths
        List<RoutingResult^>^ LibavoidRouter::RouteMultiplePaths(
            List<Tuple<ManagedPoint, ManagedPoint, PortDirection, PortDirection>^>^ connections,
            List<ManagedRect>^ nodes)
        {
            List<RoutingResult^>^ results = gcnew List<RoutingResult^>();

            int connectionCount = connections->Count;
            for (int i = 0; i < connectionCount; i++)
            {
                Tuple<ManagedPoint, ManagedPoint, PortDirection, PortDirection>^ connection = connections[i];
                ManagedPoint source = connection->Item1;
                ManagedPoint target = connection->Item2;
                PortDirection sourceDir = connection->Item3;
                PortDirection targetDir = connection->Item4;

                // Use nodes as obstacles
                RoutingResult^ result = RoutePath(
                    source,
                    target,
                    sourceDir,
                    targetDir,
                    ManagedRect(source.X - 20, source.Y - 20, 40, 40),
                    ManagedRect(target.X - 20, target.Y - 20, 40, 40),
                    nodes);

                results->Add(result);
            }

            return results;
        }

        // Clear cache
        void LibavoidRouter::ClearCache()
        {
            if (cachedResults != nullptr)
            {
                cachedResults->Clear();
            }
        }

    } // namespace LibavoidWrapper

} // namespace SunEyeVision
