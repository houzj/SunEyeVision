using System;
using System.Collections.Generic;
using System.Reflection;
using System.Windows;
using SunEyeVision.UI.Models;

namespace SunEyeVision.UI.Converters
{
    /// <summary>
    /// æ§åˆ¶è°ƒè¯•è¾“å‡ºçš„é™æ€ç±»
    /// </summary>
    internal static class DebugHelper
    {
        /// <summary>
        /// æ˜¯å¦å¯ç”¨è°ƒè¯•è¾“å‡º
        /// </summary>
        public static bool EnableDebugOutput = false;

        /// <summary>
        /// æ¡ä»¶è°ƒè¯•è¾“å‡º
        /// </summary>
        public static void WriteLine(string format, params object[] args)
        {
            if (EnableDebugOutput)
                DebugHelper.WriteLine(format, args);
        }

        public static void WriteLine(string message)
        {
            if (EnableDebugOutput)
                DebugHelper.WriteLine(message);
        }
    }
{
    /// <summary>
    /// ç«¯å£ä½ç½®ç±»å‹
    /// </summary>
    public enum PortPositionType
    {
        Left,       // å·¦ä¾§ç«¯å£
        Right,      // å³ä¾§ç«¯å£
        Top,        // é¡¶éƒ¨ç«¯å£
        Bottom      // åº•éƒ¨ç«¯å£
    }

    /// <summary>
    /// ç«¯å£ç»„åˆç±»å‹ï¼?6ç§ç»„åˆçš„ç®€åŒ–åˆ†ç±»ï¼‰
    /// </summary>
    public enum PortCombinationType
    {
        // ç›¸å¯¹æ–¹å‘çš„ç»„å?
        LeftToRight,      // æºå·¦ä¾?-> ç›®æ ‡å³ä¾§
        RightToLeft,      // æºå³ä¾?-> ç›®æ ‡å·¦ä¾§
        TopToBottom,      // æºé¡¶éƒ?-> ç›®æ ‡åº•éƒ¨
        BottomToTop,      // æºåº•éƒ?-> ç›®æ ‡é¡¶éƒ¨
        
        // åŒå‘çš„ç»„å?
        LeftToLeft,       // æºå·¦ä¾?-> ç›®æ ‡å·¦ä¾§
        RightToRight,     // æºå³ä¾?-> ç›®æ ‡å³ä¾§
        TopToTop,         // æºé¡¶éƒ?-> ç›®æ ‡é¡¶éƒ¨
        BottomToBottom,   // æºåº•éƒ?-> ç›®æ ‡åº•éƒ¨
        
        // å‚ç›´-æ°´å¹³çš„ç»„å?
        LeftToBottom,     // æºå·¦ä¾?-> ç›®æ ‡åº•éƒ¨
        LeftToTop,        // æºå·¦ä¾?-> ç›®æ ‡é¡¶éƒ¨
        RightToBottom,    // æºå³ä¾?-> ç›®æ ‡åº•éƒ¨
        RightToTop,       // æºå³ä¾?-> ç›®æ ‡é¡¶éƒ¨
        
        // æ°´å¹³-å‚ç›´çš„ç»„å?
        TopToLeft,        // æºé¡¶éƒ?-> ç›®æ ‡å·¦ä¾§
        TopToRight,       // æºé¡¶éƒ?-> ç›®æ ‡å³ä¾§
        BottomToLeft,     // æºåº•éƒ?-> ç›®æ ‡å·¦ä¾§
        BottomToRight     // æºåº•éƒ?-> ç›®æ ‡å³ä¾§
    }

    /// <summary>
    /// èŠ‚ç‚¹ç›¸å¯¹ä½ç½®ç±»å‹
    /// </summary>
    public enum NodeRelativePosition
    {
        LeftOfTarget,          // æºèŠ‚ç‚¹åœ¨ç›®æ ‡èŠ‚ç‚¹å·¦ä¾§
        RightOfTarget,         // æºèŠ‚ç‚¹åœ¨ç›®æ ‡èŠ‚ç‚¹å³ä¾§
        AboveTarget,           // æºèŠ‚ç‚¹åœ¨ç›®æ ‡èŠ‚ç‚¹ä¸Šæ–¹
        BelowTarget,           // æºèŠ‚ç‚¹åœ¨ç›®æ ‡èŠ‚ç‚¹ä¸‹æ–¹
        HorizontallyOverlapping,  // æ°´å¹³æ–¹å‘é‡å 
        VerticallyOverlapping     // å‚ç›´æ–¹å‘é‡å 
    }

    /// <summary>
    /// éšœç¢èŠ‚ç‚¹ä¿¡æ¯
    /// </summary>
    public class ObstacleNode
    {
        public WorkflowNode? Node { get; set; }
        public double Left { get; set; }
        public double Right { get; set; }
        public double Top { get; set; }
        public double Bottom { get; set; }
        public Point Center { get; set; }
    }

    /// <summary>
    /// ç›´æ¥è·¯å¾„ç­–ç•¥ - æ™ºèƒ½è·¯å¾„ç”Ÿæˆ
    /// </summary>
    public class DirectPathStrategy : BasePathStrategy
    {
        private readonly NodeRelationshipAnalyzer _relationshipAnalyzer;
        private readonly PathValidator _pathValidator;
        
        // åŸºç¡€é…ç½®
        private const double MinGapThreshold = 5.0;  // æœ€å°é—´è·é˜ˆå€?
        private const double BaseSafeDistance = 20.0;  // åŸºç¡€å®‰å…¨è·ç¦»
        private const double MaxSafeDistance = 50.0;   // æœ€å¤§å®‰å…¨è·ç¦?
        
        // è¿‡æ¸¡ç‚¹è·ç¦»å› å­?
        private const double MinTransitionFactor = 0.03;  // æœ€å°è¿‡æ¸¡å› å­?
        private const double MaxTransitionFactor = 0.08;  // æœ€å¤§è¿‡æ¸¡å› å­?

        public DirectPathStrategy(PathConfiguration config, NodeRelationshipAnalyzer? analyzer = null, PathValidator? validator = null)
            : base(config)
        {
            _relationshipAnalyzer = analyzer ?? new NodeRelationshipAnalyzer(config);
            _pathValidator = validator ?? new PathValidator(config);
        }

        public override bool CanHandle(PathContext context)
        {
            // å§‹ç»ˆå¯ä»¥å¤„ç†ï¼Œå†…éƒ¨å†³å®šä½¿ç”¨æ™ºèƒ½è·¯å¾„è¿˜æ˜¯é€šç”¨è·¯å¾„
            return true;
        }

        public override List<Point> CalculatePath(PathContext context)
        {
            var segments = new List<Point>();
            Point startPoint = context.StartPoint;
            Point endPoint = context.ArrowTailPoint;

            DebugHelper.WriteLine($"[DirectPathStrategy] ========== CalculatePath å¼€å§?==========");
            DebugHelper.WriteLine($"[DirectPathStrategy] æºèŠ‚ç‚? {context.SourceNode.Name}, ç›®æ ‡èŠ‚ç‚¹: {context.TargetNode.Name}");
            DebugHelper.WriteLine($"[DirectPathStrategy] æºç«¯å? {context.SourcePort}, ç›®æ ‡ç«¯å£: {context.TargetPort}");
            DebugHelper.WriteLine($"[DirectPathStrategy] èµ·ç‚¹: {startPoint}, ç»ˆç‚¹: {endPoint}");

            // ========== èŠ‚ç‚¹ä½ç½®ç›‘æ§ ==========
            AnalyzeNodePositions(context);
            // ===================================

            // æ­¥éª¤1: åˆ†æç«¯å£ç»„åˆç±»å‹
            PortCombinationType portCombo = DeterminePortCombination(context.SourcePort, context.TargetPort);
            DebugHelper.WriteLine($"[DirectPathStrategy] ç«¯å£ç»„åˆ: {portCombo}");

            // æ­¥éª¤2: åˆ†æèŠ‚ç‚¹ç›¸å¯¹ä½ç½®
            NodeRelativePosition relativePos = AnalyzeNodeRelativePosition(context);
            DebugHelper.WriteLine($"[DirectPathStrategy] èŠ‚ç‚¹ç›¸å¯¹ä½ç½®: {relativePos}");

            // æ­¥éª¤3: è®¡ç®—æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„æœ€å¤§å¤–æ¥çŸ©å½?
            var boundingRect = CalculateBoundingRectangle(context);
            DebugHelper.WriteLine($"[DirectPathStrategy] è¾¹ç•ŒçŸ©å½¢: X=[{boundingRect.X:F1}, {boundingRect.Right:F1}], Y=[{boundingRect.Y:F1}, {boundingRect.Bottom:F1}]");

            // æ­¥éª¤4: è¿‡æ»¤è¾¹ç•ŒçŸ©å½¢å†…çš„éšœç¢èŠ‚ç‚¹
            var obstaclesInRect = FilterObstaclesInBoundingRect(context, boundingRect);
            DebugHelper.WriteLine($"[DirectPathStrategy] è¾¹ç•ŒçŸ©å½¢å†…éšœç¢æ•°é‡? {obstaclesInRect.Count}");

            // æ­¥éª¤5: è®¡ç®—è¿‡æ¸¡ç‚?
            Point transitionPoint = CalculateTransitionPoint(context, portCombo, relativePos);
            DebugHelper.WriteLine($"[DirectPathStrategy] è¿‡æ¸¡ç‚? {transitionPoint}");

            // æ­¥éª¤6: è®¡ç®—æœ€å°é—´è·ï¼ˆéšœç¢èŠ‚ç‚¹ä¹‹é—´ï¼?
            double minGap = CalculateMinGapInBoundingRect(obstaclesInRect);
            DebugHelper.WriteLine($"[DirectPathStrategy] éšœç¢é—´æœ€å°é—´è·? {minGap:F2}px");

            // æ­¥éª¤7: è®¡ç®—å®‰å…¨è·ç¦»
            double safeDistance = CalculateSafeDistance(obstaclesInRect.Count);
            DebugHelper.WriteLine($"[DirectPathStrategy] å®‰å…¨è·ç¦»: {safeDistance:F2}px");

            // æ­¥éª¤8: ç”Ÿæˆè·¯å¾„
            // å½“æœ‰éšœç¢ç‰©æ—¶ï¼Œæ€»æ˜¯ç”Ÿæˆç»•è¡Œè·¯å¾„
            if (obstaclesInRect.Count > 0)
            {
                // æœ‰éšœç¢ç‰©ï¼Œä½¿ç”¨ç»•è¡Œè·¯å¾„ï¼ˆå‚ç›´æˆ–æ°´å¹³ç»•è¡Œï¼‰
                DebugHelper.WriteLine($"[DirectPathStrategy] æ£€æµ‹åˆ°{obstaclesInRect.Count}ä¸ªéšœç¢ç‰©ï¼Œä½¿ç”¨ç»•è¡Œè·¯å¾?);
                segments = GenerateSmartPath(context, portCombo, relativePos, transitionPoint, minGap, safeDistance);
            }
            else if (minGap >= MinGapThreshold)
            {
                // æ— éšœç¢ç‰©ä¸”æœ‰è¶³å¤Ÿé—´è·ï¼Œä½¿ç”¨æœ€å°é—´è·æ–¹æ¡?
                DebugHelper.WriteLine($"[DirectPathStrategy] ä½¿ç”¨æ™ºèƒ½è·¯å¾„ï¼ˆæœ€å°é—´è·æ–¹æ¡ˆï¼‰");
                segments = GenerateSmartPath(context, portCombo, relativePos, transitionPoint, minGap, safeDistance);
            }
            else
            {
                // æ— éšœç¢ç‰©ä¸”é—´è·æ­£å¸¸ï¼Œä½¿ç”¨é€šç”¨ç›´çº¿è·¯å¾„
                DebugHelper.WriteLine($"[DirectPathStrategy] ä½¿ç”¨é€šç”¨è·¯å¾„ï¼ˆæ— éšœç¢ï¼?);
                segments = GenerateUniversalPathFromTransition_Optimized(context, portCombo, relativePos, transitionPoint);
            }

            DebugHelper.WriteLine($"[DirectPathStrategy] è·¯å¾„ç‚¹æ•°: {segments.Count}");
            for (int i = 0; i < segments.Count; i++)
            {
                DebugHelper.WriteLine($"  ç‚¹{i}: {segments[i]}");
            }
            DebugHelper.WriteLine($"[DirectPathStrategy] ========== CalculatePath ç»“æŸ ==========");

            return segments;
        }

        /// <summary>
        /// åˆ†æèŠ‚ç‚¹ä½ç½®å’Œç›¸å¯¹å…³ç³?
        /// </summary>
        private void AnalyzeNodePositions(PathContext context)
        {
            DebugHelper.WriteLine($"[NodePositionMonitor] ========== èŠ‚ç‚¹ä½ç½®ç›‘æ§ ==========");

            // æºèŠ‚ç‚¹ä¿¡æ?
            double sourceLeft = context.SourceNode.Position.X;
            double sourceRight = context.SourceNode.Position.X + _config.NodeWidth;
            double sourceTop = context.SourceNode.Position.Y;
            double sourceBottom = context.SourceNode.Position.Y + _config.NodeHeight;
            double sourceCenterX = (sourceLeft + sourceRight) / 2;
            double sourceCenterY = (sourceTop + sourceBottom) / 2;

            // ç›®æ ‡èŠ‚ç‚¹ä¿¡æ¯
            double targetLeft = context.TargetNode.Position.X;
            double targetRight = context.TargetNode.Position.X + _config.NodeWidth;
            double targetTop = context.TargetNode.Position.Y;
            double targetBottom = context.TargetNode.Position.Y + _config.NodeHeight;
            double targetCenterX = (targetLeft + targetRight) / 2;
            double targetCenterY = (targetTop + targetBottom) / 2;

            DebugHelper.WriteLine($"[NodePositionMonitor] æºèŠ‚ç‚? {context.SourceNode.Name} (ID: {context.SourceNode.Id.ToString().Substring(0, 8)}...)");
            DebugHelper.WriteLine($"              åæ ‡: ({context.SourceNode.Position.X:F1}, {context.SourceNode.Position.Y:F1})");
            DebugHelper.WriteLine($"              è¾¹ç•Œ: X=[{sourceLeft:F1}, {sourceRight:F1}], Y=[{sourceTop:F1}, {sourceBottom:F1}]");
            DebugHelper.WriteLine($"              ä¸­å¿ƒ: ({sourceCenterX:F1}, {sourceCenterY:F1})");

            DebugHelper.WriteLine($"[NodePositionMonitor] ç›®æ ‡èŠ‚ç‚¹: {context.TargetNode.Name} (ID: {context.TargetNode.Id.ToString().Substring(0, 8)}...)");
            DebugHelper.WriteLine($"              åæ ‡: ({context.TargetNode.Position.X:F1}, {context.TargetNode.Position.Y:F1})");
            DebugHelper.WriteLine($"              è¾¹ç•Œ: X=[{targetLeft:F1}, {targetRight:F1}], Y=[{targetTop:F1}, {targetBottom:F1}]");
            DebugHelper.WriteLine($"              ä¸­å¿ƒ: ({targetCenterX:F1}, {targetCenterY:F1})");

            // ç›¸å¯¹ä½ç½®åˆ†æ
            double deltaX = targetCenterX - sourceCenterX;
            double deltaY = targetCenterY - sourceCenterY;
            double distance = Math.Sqrt(deltaX * deltaX + deltaY * deltaY);

            DebugHelper.WriteLine($"[NodePositionMonitor] ç›¸å¯¹ä½ç½®åˆ†æ:");
            DebugHelper.WriteLine($"              æ°´å¹³è·ç¦»(Î”X): {deltaX:F1}px ({(deltaX > 0 ? "ç›®æ ‡åœ¨å³" : "ç›®æ ‡åœ¨å·¦")})");
            DebugHelper.WriteLine($"              å‚ç›´è·ç¦»(Î”Y): {deltaY:F1}px ({(deltaY > 0 ? "ç›®æ ‡åœ¨ä¸‹" : "ç›®æ ‡åœ¨ä¸Š")})");
            DebugHelper.WriteLine($"              ç›´çº¿è·ç¦»: {distance:F1}px");

            // æ°´å¹³é‡å åˆ†æ
            double horizontalOverlap = Math.Min(sourceRight, targetRight) - Math.Max(sourceLeft, targetLeft);
            bool horizontallyOverlapping = horizontalOverlap > 0;
            DebugHelper.WriteLine($"[NodePositionMonitor] æ°´å¹³æ–¹å‘: {(horizontallyOverlapping ? $"é‡å  {horizontalOverlap:F1}px" : "åˆ†ç¦»")}");

            // å‚ç›´é‡å åˆ†æ
            double verticalOverlap = Math.Min(sourceBottom, targetBottom) - Math.Max(sourceTop, targetTop);
            bool verticallyOverlapping = verticalOverlap > 0;
            DebugHelper.WriteLine($"[NodePositionMonitor] å‚ç›´æ–¹å‘: {(verticallyOverlapping ? $"é‡å  {verticalOverlap:F1}px" : "åˆ†ç¦»")}");

            // èŠ‚ç‚¹è¾¹ç•Œæœ€å°é—´è·?
            double horizontalGap = Math.Max(0, Math.Max(sourceLeft, targetLeft) - Math.Min(sourceRight, targetRight));
            double verticalGap = Math.Max(0, Math.Max(sourceTop, targetTop) - Math.Min(sourceBottom, targetBottom));
            DebugHelper.WriteLine($"[NodePositionMonitor] èŠ‚ç‚¹é—´è·: æ°´å¹³ {horizontalGap:F1}px, å‚ç›´ {verticalGap:F1}px");

            // å¯è§†åŒ–å¸ƒå±€
            DebugHelper.WriteLine($"[NodePositionMonitor] å¯è§†åŒ–å¸ƒå±€:");
            DebugHelper.WriteLine($"              æºèŠ‚ç‚¹XèŒƒå›´: [{sourceLeft:F1}......{sourceRight:F1}]");
            DebugHelper.WriteLine($"              ç›®æ ‡èŠ‚ç‚¹XèŒƒå›´:                    [{targetLeft:F1}......{targetRight:F1}]");
            DebugHelper.WriteLine($"              è¾¹ç•ŒçŸ©å½¢XèŒƒå›´:  [{Math.Min(sourceLeft, targetLeft):F1}..................{Math.Max(sourceRight, targetRight):F1}]");

            DebugHelper.WriteLine($"[NodePositionMonitor] ========================================");
        }

        /// <summary>
        /// ç¡®å®šç«¯å£ç»„åˆç±»å‹
        /// </summary>
        private PortCombinationType DeterminePortCombination(PortType sourcePort, PortType targetPort)
        {
            return (sourcePort, targetPort) switch
            {
                (PortType.LeftPort, PortType.RightPort) => PortCombinationType.LeftToRight,
                (PortType.RightPort, PortType.LeftPort) => PortCombinationType.RightToLeft,
                (PortType.TopPort, PortType.BottomPort) => PortCombinationType.TopToBottom,
                (PortType.BottomPort, PortType.TopPort) => PortCombinationType.BottomToTop,
                (PortType.LeftPort, PortType.LeftPort) => PortCombinationType.LeftToLeft,
                (PortType.RightPort, PortType.RightPort) => PortCombinationType.RightToRight,
                (PortType.TopPort, PortType.TopPort) => PortCombinationType.TopToTop,
                (PortType.BottomPort, PortType.BottomPort) => PortCombinationType.BottomToBottom,
                (PortType.LeftPort, PortType.BottomPort) => PortCombinationType.LeftToBottom,
                (PortType.LeftPort, PortType.TopPort) => PortCombinationType.LeftToTop,
                (PortType.RightPort, PortType.BottomPort) => PortCombinationType.RightToBottom,
                (PortType.RightPort, PortType.TopPort) => PortCombinationType.RightToTop,
                (PortType.TopPort, PortType.LeftPort) => PortCombinationType.TopToLeft,
                (PortType.TopPort, PortType.RightPort) => PortCombinationType.TopToRight,
                (PortType.BottomPort, PortType.LeftPort) => PortCombinationType.BottomToLeft,
                (PortType.BottomPort, PortType.RightPort) => PortCombinationType.BottomToRight,
                _ => PortCombinationType.LeftToRight  // é»˜è®¤å€?
            };
        }

        /// <summary>
        /// åˆ†æèŠ‚ç‚¹ç›¸å¯¹ä½ç½®
        /// </summary>
        private NodeRelativePosition AnalyzeNodeRelativePosition(PathContext context)
        {
            double sourceLeft = context.SourceNode.Position.X;
            double sourceRight = context.SourceNode.Position.X + _config.NodeWidth;
            double sourceTop = context.SourceNode.Position.Y;
            double sourceBottom = context.SourceNode.Position.Y + _config.NodeHeight;

            double targetLeft = context.TargetNode.Position.X;
            double targetRight = context.TargetNode.Position.X + _config.NodeWidth;
            double targetTop = context.TargetNode.Position.Y;
            double targetBottom = context.TargetNode.Position.Y + _config.NodeHeight;

            // æ£€æŸ¥æ°´å¹³æ–¹å‘å…³ç³?
            if (sourceRight < targetLeft)
            {
                return NodeRelativePosition.LeftOfTarget;
            }
            else if (sourceLeft > targetRight)
            {
                return NodeRelativePosition.RightOfTarget;
            }

            // æ£€æŸ¥å‚ç›´æ–¹å‘å…³ç³?
            if (sourceBottom < targetTop)
            {
                return NodeRelativePosition.AboveTarget;
            }
            else if (sourceTop > targetBottom)
            {
                return NodeRelativePosition.BelowTarget;
            }

            // æ£€æŸ¥é‡å å…³ç³?
            double horizontalOverlap = Math.Min(sourceRight, targetRight) - Math.Max(sourceLeft, targetLeft);
            double verticalOverlap = Math.Min(sourceBottom, targetBottom) - Math.Max(sourceTop, targetTop);

            if (horizontalOverlap > 0 && horizontalOverlap > verticalOverlap)
            {
                return NodeRelativePosition.HorizontallyOverlapping;
            }
            else if (verticalOverlap > 0)
            {
                return NodeRelativePosition.VerticallyOverlapping;
            }

            // é»˜è®¤è¿”å›æ°´å¹³é‡å 
            return NodeRelativePosition.HorizontallyOverlapping;
        }

        /// <summary>
        /// è®¡ç®—æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„æœ€å¤§å¤–æ¥çŸ©å½?
        /// </summary>
        private Rect CalculateBoundingRectangle(PathContext context)
        {
            double sourceLeft = context.SourceNode.Position.X;
            double sourceRight = context.SourceNode.Position.X + _config.NodeWidth;
            double sourceTop = context.SourceNode.Position.Y;
            double sourceBottom = context.SourceNode.Position.Y + _config.NodeHeight;

            double targetLeft = context.TargetNode.Position.X;
            double targetRight = context.TargetNode.Position.X + _config.NodeWidth;
            double targetTop = context.TargetNode.Position.Y;
            double targetBottom = context.TargetNode.Position.Y + _config.NodeHeight;

            // è®¡ç®—åŒ…å›´ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€å¤§çŸ©å½?
            double minX = Math.Min(sourceLeft, targetLeft);
            double maxX = Math.Max(sourceRight, targetRight);
            double minY = Math.Min(sourceTop, targetTop);
            double maxY = Math.Max(sourceBottom, targetBottom);

            // è®¡ç®—çŸ©å½¢çš„å®½åº¦å’Œé«˜åº¦
            double rectWidth = maxX - minX;
            double rectHeight = maxY - minY;

            // ä½¿ç”¨æœ€å¤§è¾¹é•¿ä½œä¸ºæ­£æ–¹å½¢çš„è¾¹é•?å¢åŠ æœç´¢èŒƒå›´
            double maxSide = Math.Max(rectWidth, rectHeight);

            // ä»¥æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„ä¸­å¿ƒç‚¹ä¸ºåŸºå‡†,æ„å»ºæ­£æ–¹å½¢æœç´¢åŒºåŸ?
            double centerX = (minX + maxX) / 2;
            double centerY = (minY + maxY) / 2;

            // åˆ›å»ºåŸºäºæœ€å¤§è¾¹çš„æ­£æ–¹å½¢
            var boundingRect = new Rect(
                centerX - maxSide / 2,
                centerY - maxSide / 2,
                maxSide,
                maxSide
            );

            // æ˜¾ç¤ºæœ€å¤§å¤–æ¥çŸ©å½¢ä¿¡æ?
            DebugHelper.WriteLine($"[BoundingRectangle] ========== æœ€å¤§å¤–æ¥çŸ©å½?æ­£æ–¹å½? ==========");
            DebugHelper.WriteLine($"[BoundingRectangle] æºèŠ‚ç‚? {context.SourceNode.Name}");
            DebugHelper.WriteLine($"[BoundingRectangle]   è¾¹ç•Œ: X=[{sourceLeft:F1}, {sourceRight:F1}], Y=[{sourceTop:F1}, {sourceBottom:F1}]");
            DebugHelper.WriteLine($"[BoundingRectangle]   å°ºå¯¸: å®½åº¦={sourceRight - sourceLeft:F1}, é«˜åº¦={sourceBottom - sourceTop:F1}");
            DebugHelper.WriteLine($"[BoundingRectangle] ç›®æ ‡èŠ‚ç‚¹: {context.TargetNode.Name}");
            DebugHelper.WriteLine($"[BoundingRectangle]   è¾¹ç•Œ: X=[{targetLeft:F1}, {targetRight:F1}], Y=[{targetTop:F1}, {targetBottom:F1}]");
            DebugHelper.WriteLine($"[BoundingRectangle]   å°ºå¯¸: å®½åº¦={targetRight - targetLeft:F1}, é«˜åº¦={targetBottom - targetTop:F1}");
            DebugHelper.WriteLine($"[BoundingRectangle] åŸå§‹çŸ©å½¢: X=[{minX:F1}, {maxX:F1}], Y=[{minY:F1}, {maxY:F1}]");
            DebugHelper.WriteLine($"[BoundingRectangle]   åŸå§‹å°ºå¯¸: å®½åº¦={rectWidth:F1}, é«˜åº¦={rectHeight:F1}");
            DebugHelper.WriteLine($"[BoundingRectangle]   æœ€å¤§è¾¹é•? {maxSide:F1}px");
            DebugHelper.WriteLine($"[BoundingRectangle] æ­£æ–¹å½¢æœç´¢åŒºåŸ?");
            DebugHelper.WriteLine($"[BoundingRectangle]   ä¸­å¿ƒç‚? ({centerX:F1}, {centerY:F1})");
            DebugHelper.WriteLine($"[BoundingRectangle]   è¾¹ç•Œ: X=[{boundingRect.X:F1}, {boundingRect.Right:F1}], Y=[{boundingRect.Y:F1}, {boundingRect.Bottom:F1}]");
            DebugHelper.WriteLine($"[BoundingRectangle]   å°ºå¯¸: å®½åº¦={boundingRect.Width:F1}, é«˜åº¦={boundingRect.Height:F1}");
            DebugHelper.WriteLine($"[BoundingRectangle]   é¢ç§¯: {boundingRect.Width * boundingRect.Height:F1} pxÂ²");
            DebugHelper.WriteLine($"[BoundingRectangle]   æœç´¢èŒƒå›´æ‰©å±•: {(maxSide * maxSide) / (rectWidth * rectHeight):F2}x");
            DebugHelper.WriteLine($"[BoundingRectangle] ========================================");

            return boundingRect;
        }

        /// <summary>
        /// è¿‡æ»¤è¾¹ç•ŒçŸ©å½¢å†…çš„éšœç¢èŠ‚ç‚¹ï¼ˆO(N)å¤æ‚åº¦ï¼‰
        /// </summary>
        private List<ObstacleNode> FilterObstaclesInBoundingRect(PathContext context, Rect boundingRect)
        {
            var obstacles = new List<ObstacleNode>();

            if (context.Obstacles == null || context.Obstacles.Count == 0)
            {
                
                DebugHelper.WriteLine($"[FilterObstacles] æ— éšœç¢èŠ‚ç‚?);
                return obstacles;
            }

            DebugHelper.WriteLine($"[FilterObstacles] ========== å¼€å§‹åˆ†æè¾¹ç•ŒçŸ©å½¢åŒ…å«é€»è¾‘ ==========");
            DebugHelper.WriteLine($"[FilterObstacles] è¾¹ç•ŒçŸ©å½¢: X=[{boundingRect.X:F1}, {boundingRect.Right:F1}], Y=[{boundingRect.Y:F1}, {boundingRect.Bottom:F1}]");
            DebugHelper.WriteLine($"[FilterObstacles] è¾¹ç•ŒçŸ©å½¢å°ºå¯¸: å®½åº¦={boundingRect.Width:F1}, é«˜åº¦={boundingRect.Height:F1}");
            DebugHelper.WriteLine($"[FilterObstacles] æ€»éšœç¢æ•°: {context.Obstacles.Count}");

            int includedCount = 0;
            int excludedCount = 0;

            foreach (var obstacle in context.Obstacles)
            {
                // æ’é™¤æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹
                if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                {
                    DebugHelper.WriteLine($"[FilterObstacles]   â?æ’é™¤: {obstacle.Name} (ID: {obstacle.Id.ToString().Substring(0, 8)}...) - æº?ç›®æ ‡èŠ‚ç‚¹");
                    excludedCount++;
                    continue;
                }

                double obsLeft = obstacle.Position.X;
                double obsRight = obstacle.Position.X + _config.NodeWidth;
                double obsTop = obstacle.Position.Y;
                double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                // æ£€æŸ¥æ˜¯å¦åœ¨è¾¹ç•ŒçŸ©å½¢å†…æˆ–ä¸è¾¹ç•ŒçŸ©å½¢ç›¸äº?
                bool horizontallyOverlaps = obsRight >= boundingRect.X && obsLeft <= boundingRect.Right;
                bool verticallyOverlaps = obsBottom >= boundingRect.Y && obsTop <= boundingRect.Bottom;
                bool isInBoundingRect = horizontallyOverlaps && verticallyOverlaps;

                // è¯¦ç»†åˆ†æåŒ…å«å…³ç³»
                string inclusionReason = "";
                if (isInBoundingRect)
                {
                    // åˆ†æå…·ä½“åŒ…å«æ–¹å¼
                    bool fullyInside = obsLeft >= boundingRect.X && obsRight <= boundingRect.Right &&
                                     obsTop >= boundingRect.Y && obsBottom <= boundingRect.Bottom;
                    bool partiallyOverlaps = !fullyInside;

                    if (fullyInside)
                    {
                        inclusionReason = "å®Œå…¨åœ¨è¾¹ç•ŒçŸ©å½¢å†…";
                    }
                    else if (partiallyOverlaps)
                    {
                        inclusionReason = "ä¸è¾¹ç•ŒçŸ©å½¢éƒ¨åˆ†ç›¸äº?;
                    }

                    obstacles.Add(new ObstacleNode
                    {
                        Node = obstacle,
                        Left = obsLeft,
                        Right = obsRight,
                        Top = obsTop,
                        Bottom = obsBottom,
                        Center = new Point((obsLeft + obsRight) / 2, (obsTop + obsBottom) / 2)
                    });

                    includedCount++;

                    DebugHelper.WriteLine($"[FilterObstacles]   âœ?åŒ…å«: {obstacle.Name} (ID: {obstacle.Id.ToString().Substring(0, 8)}...)");
                    DebugHelper.WriteLine($"            éšœç¢èŒƒå›´: X=[{obsLeft:F1}, {obsRight:F1}], Y=[{obsTop:F1}, {obsBottom:F1}]");
                    DebugHelper.WriteLine($"            åŒ…å«æ–¹å¼: {inclusionReason}");
                    DebugHelper.WriteLine($"            æ°´å¹³é‡å : {horizontallyOverlaps}, å‚ç›´é‡å : {verticallyOverlaps}");

                    // è¯¦ç»†ç›¸äº¤åˆ†æ
                    if (partiallyOverlaps)
                    {
                        DebugHelper.WriteLine($"            ç›¸äº¤è¯¦æƒ…:");
                        DebugHelper.WriteLine($"              Xæ–¹å‘: éšœç¢å?{obsRight:F1}) >= çŸ©å½¢å·?{boundingRect.X:F1}) ? {obsRight >= boundingRect.X}, " +
                                                        $"éšœç¢å·?{obsLeft:F1}) <= çŸ©å½¢å?{boundingRect.Right:F1}) ? {obsLeft <= boundingRect.Right}");
                        DebugHelper.WriteLine($"              Yæ–¹å‘: éšœç¢ä¸?{obsBottom:F1}) >= çŸ©å½¢ä¸?{boundingRect.Y:F1}) ? {obsBottom >= boundingRect.Y}, " +
                                                        $"éšœç¢ä¸?{obsTop:F1}) <= çŸ©å½¢ä¸?{boundingRect.Bottom:F1}) ? {obsTop <= boundingRect.Bottom}");
                    }
                }
                else
                {
                    // åˆ†æä¸åŒ…å«çš„åŸå› 
                    if (!horizontallyOverlaps)
                    {
                        inclusionReason = $"æ°´å¹³æ–¹å‘ä¸ç›¸äº?(éšœç¢X=[{obsLeft:F1}, {obsRight:F1}], çŸ©å½¢X=[{boundingRect.X:F1}, {boundingRect.Right:F1}])";
                    }
                    else if (!verticallyOverlaps)
                    {
                        inclusionReason = $"å‚ç›´æ–¹å‘ä¸ç›¸äº?(éšœç¢Y=[{obsTop:F1}, {obsBottom:F1}], çŸ©å½¢Y=[{boundingRect.Y:F1}, {boundingRect.Bottom:F1}])";
                    }

                    excludedCount++;

                    DebugHelper.WriteLine($"[FilterObstacles]   âœ?ä¸åŒ…å? {obstacle.Name} (ID: {obstacle.Id.ToString().Substring(0, 8)}...) - {inclusionReason}");
                }
            }

            DebugHelper.WriteLine($"[FilterObstacles] åˆ†æç»“æœ: åŒ…å« {includedCount} ä¸? æ’é™¤ {excludedCount} ä¸?);
            DebugHelper.WriteLine($"[FilterObstacles] ========== åŒ…å«é€»è¾‘åˆ†æç»“æŸ ==========");

            return obstacles;
        }

        /// <summary>
        /// è®¡ç®—è¿‡æ¸¡ç‚¹ï¼ˆåŸºäºç›¸å¯¹ä½ç½®å’Œç«¯å£æ–¹å‘ï¼‰
        /// </summary>
        private Point CalculateTransitionPoint(PathContext context, PortCombinationType portCombo, NodeRelativePosition relativePos)
        {
            Point startPoint = context.StartPoint;

            // è·å–æºèŠ‚ç‚¹è¾¹ç•?
            double sourceLeft = context.SourceNode.Position.X;
            double sourceRight = context.SourceNode.Position.X + _config.NodeWidth;
            double sourceTop = context.SourceNode.Position.Y;
            double sourceBottom = context.SourceNode.Position.Y + _config.NodeHeight;

            // æ ¹æ®ç«¯å£æ–¹å‘ç¡®å®šè¿‡æ¸¡è·ç¦»
            double transitionDistance = CalculateTransitionDistance(context, relativePos);

            // è®¡ç®—åˆå§‹è¿‡æ¸¡ç‚?
            Point initialTransition = portCombo switch
            {
                // ç›¸å¯¹æ–¹å‘çš„ç»„åˆï¼šç›´æ¥å‘ç›®æ ‡æ–¹å‘å»¶ä¼?
                PortCombinationType.LeftToRight when relativePos == NodeRelativePosition.LeftOfTarget
                    => new Point(startPoint.X + transitionDistance, startPoint.Y),
                PortCombinationType.RightToLeft when relativePos == NodeRelativePosition.RightOfTarget
                    => new Point(startPoint.X - transitionDistance, startPoint.Y),
                PortCombinationType.TopToBottom when relativePos == NodeRelativePosition.AboveTarget
                    => new Point(startPoint.X, startPoint.Y + transitionDistance),
                PortCombinationType.BottomToTop when relativePos == NodeRelativePosition.BelowTarget
                    => new Point(startPoint.X, startPoint.Y - transitionDistance),

                // åŒå‘çš„ç»„åˆï¼šå…ˆæ²¿ç«¯å£æ–¹å‘ç¦»å¼€æºèŠ‚ç‚¹ï¼Œç„¶åæ ¹æ®ç›®æ ‡ä½ç½®è°ƒæ•´
                PortCombinationType.LeftToLeft when relativePos == NodeRelativePosition.LeftOfTarget
                    => CalculateTransitionPointLeftToLeft(context, startPoint, transitionDistance),
                PortCombinationType.LeftToLeft when relativePos == NodeRelativePosition.RightOfTarget
                    => new Point(startPoint.X - transitionDistance, startPoint.Y),
                PortCombinationType.RightToRight when relativePos == NodeRelativePosition.RightOfTarget
                    => CalculateTransitionPointRightToRight(context, startPoint, transitionDistance),
                PortCombinationType.RightToRight when relativePos == NodeRelativePosition.LeftOfTarget
                    => new Point(startPoint.X + transitionDistance, startPoint.Y),
                PortCombinationType.TopToTop when relativePos == NodeRelativePosition.AboveTarget
                    => CalculateTransitionPointTopToTop(context, startPoint, transitionDistance),
                PortCombinationType.TopToTop when relativePos == NodeRelativePosition.BelowTarget
                    => new Point(startPoint.X, startPoint.Y + transitionDistance),
                PortCombinationType.BottomToBottom when relativePos == NodeRelativePosition.BelowTarget
                    => CalculateTransitionPointBottomToBottom(context, startPoint, transitionDistance),
                PortCombinationType.BottomToBottom when relativePos == NodeRelativePosition.AboveTarget
                    => new Point(startPoint.X, startPoint.Y - transitionDistance),

                // å‚ç›´-æ°´å¹³ç»„åˆï¼šåŸºäºç›¸å¯¹ä½ç½®é€‰æ‹©
                PortCombinationType.LeftToBottom when relativePos == NodeRelativePosition.LeftOfTarget
                    => new Point(startPoint.X + transitionDistance, startPoint.Y),
                PortCombinationType.LeftToTop when relativePos == NodeRelativePosition.LeftOfTarget
                    => new Point(startPoint.X + transitionDistance, startPoint.Y),
                PortCombinationType.RightToBottom when relativePos == NodeRelativePosition.RightOfTarget
                    => new Point(startPoint.X - transitionDistance, startPoint.Y),
                PortCombinationType.RightToTop when relativePos == NodeRelativePosition.RightOfTarget
                    => new Point(startPoint.X - transitionDistance, startPoint.Y),

                // æ°´å¹³-å‚ç›´ç»„åˆï¼šåŸºäºç›¸å¯¹ä½ç½®é€‰æ‹©
                PortCombinationType.TopToLeft when relativePos == NodeRelativePosition.AboveTarget
                    => new Point(startPoint.X, startPoint.Y + transitionDistance),
                PortCombinationType.TopToRight when relativePos == NodeRelativePosition.AboveTarget
                    => new Point(startPoint.X, startPoint.Y + transitionDistance),
                PortCombinationType.BottomToLeft when relativePos == NodeRelativePosition.BelowTarget
                    => new Point(startPoint.X, startPoint.Y - transitionDistance),
                PortCombinationType.BottomToRight when relativePos == NodeRelativePosition.BelowTarget
                    => new Point(startPoint.X, startPoint.Y - transitionDistance),

                // é»˜è®¤æƒ…å†µï¼šåŸºäºç«¯å£æ–¹å?
                _ when context.SourcePort == PortType.LeftPort => new Point(startPoint.X - transitionDistance, startPoint.Y),
                _ when context.SourcePort == PortType.RightPort => new Point(startPoint.X + transitionDistance, startPoint.Y),
                _ when context.SourcePort == PortType.TopPort => new Point(startPoint.X, startPoint.Y - transitionDistance),
                _ when context.SourcePort == PortType.BottomPort => new Point(startPoint.X, startPoint.Y + transitionDistance),
                _ => startPoint  // é»˜è®¤ä¸æ·»åŠ è¿‡æ¸¡ç‚¹
            };

            // ç¡®ä¿è¿‡æ¸¡ç‚¹åœ¨æºèŠ‚ç‚¹å¤–éƒ?
            // ç¡®å®šè¿‡æ¸¡ç‚¹çš„ä¸»è½´æ–¹å‘ï¼ˆåŸºäºåˆå§‹è¿‡æ¸¡ç‚¹ç›¸å¯¹äºèµ·ç‚¹çš„ç§»åŠ¨æ–¹å‘ï¼?
            bool isHorizontalTransition = Math.Abs(initialTransition.X - startPoint.X) > 0.01;
            bool isVerticalTransition = Math.Abs(initialTransition.Y - startPoint.Y) > 0.01;

            // æ£€æŸ¥Xåæ ‡æ˜¯å¦åœ¨æºèŠ‚ç‚¹èŒƒå›´å†?
            if (initialTransition.X >= sourceLeft && initialTransition.X <= sourceRight)
            {
                // å¦‚æœåœ¨XèŒƒå›´å†…ï¼Œéœ€è¦è°ƒæ•´Xåæ ‡åˆ°èŒƒå›´å¤–
                // æ³¨æ„ï¼šåªåœ¨Xè½´ä¸ºä¸»è¦ç§»åŠ¨æ–¹å‘æ—¶æ‰è°ƒæ•´
                if (startPoint.X <= sourceLeft)
                {
                    // èµ·ç‚¹åœ¨å·¦ä¾§ï¼Œå‘å·¦ç§»å‡º
                    initialTransition = new Point(sourceLeft - 10, initialTransition.Y);
                }
                else
                {
                    // èµ·ç‚¹åœ¨å³ä¾§ï¼Œå‘å³ç§»å‡º
                    initialTransition = new Point(sourceRight + 10, initialTransition.Y);
                }
            }

            // æ£€æŸ¥Yåæ ‡æ˜¯å¦åœ¨æºèŠ‚ç‚¹èŒƒå›´å†?
            // åªåœ¨Yè½´ä¸ºä¸»è¦ç§»åŠ¨æ–¹å‘æ—¶æ‰è°ƒæ•´Yåæ ‡
            if (isVerticalTransition && initialTransition.Y >= sourceTop && initialTransition.Y <= sourceBottom)
            {
                // å¦‚æœåœ¨YèŒƒå›´å†…ï¼Œéœ€è¦è°ƒæ•´Yåæ ‡åˆ°èŒƒå›´å¤–
                if (startPoint.Y <= sourceTop)
                {
                    // èµ·ç‚¹åœ¨ä¸Šæ–¹ï¼Œå‘ä¸Šç§»å‡º
                    initialTransition = new Point(initialTransition.X, sourceTop - 10);
                }
                else
                {
                    // èµ·ç‚¹åœ¨ä¸‹æ–¹ï¼Œå‘ä¸‹ç§»å‡º
                    initialTransition = new Point(initialTransition.X, sourceBottom + 10);
                }
            }

            return initialTransition;
        }

        /// <summary>
        /// è®¡ç®—è¿‡æ¸¡è·ç¦»ï¼ˆåŸºäºèŠ‚ç‚¹é—´è·å’Œç›¸å¯¹ä½ç½®ï¼?
        /// </summary>
        private double CalculateTransitionDistance(PathContext context, NodeRelativePosition relativePos)
        {
            Point sourcePos = context.SourceNode.Position;
            Point targetPos = context.TargetNode.Position;
            
            // è®¡ç®—èŠ‚ç‚¹é—´è·ç¦?
            double distance;
            switch (relativePos)
            {
                case NodeRelativePosition.LeftOfTarget:
                case NodeRelativePosition.RightOfTarget:
                    distance = Math.Abs(targetPos.X - sourcePos.X);
                    break;
                case NodeRelativePosition.AboveTarget:
                case NodeRelativePosition.BelowTarget:
                    distance = Math.Abs(targetPos.Y - sourcePos.Y);
                    break;
                default:
                    // é‡å æƒ…å†µï¼Œä½¿ç”¨æœ€å¤§ç»´åº?
                    distance = Math.Max(
                        Math.Abs(targetPos.X - sourcePos.X),
                        Math.Abs(targetPos.Y - sourcePos.Y)
                    );
                    break;
            }
            
            // ä½¿ç”¨åŠ¨æ€å› å­ï¼ˆ0.03-0.08ï¼?
            double factor = Math.Clamp(distance / 1000.0, MinTransitionFactor, MaxTransitionFactor);
            double transitionDistance = distance * factor;
            
            // ç¡®ä¿æœ€å°å€?
            return Math.Max(transitionDistance, 10.0);
        }

        /// <summary>
        /// è®¡ç®—æœ€å°é—´è·ï¼ˆéšœç¢èŠ‚ç‚¹ä¹‹é—´ï¼ŒO(N)å¤æ‚åº¦ï¼‰
        /// </summary>
        private double CalculateMinGapInBoundingRect(List<ObstacleNode> obstacles)
        {
            if (obstacles.Count == 0)
            {
                return double.MaxValue;
            }

            if (obstacles.Count == 1)
            {
                return double.MaxValue;
            }

            // æŠ•å½±ä¼˜åŒ–ï¼šåˆ†åˆ«è®¡ç®—Xæ–¹å‘å’ŒYæ–¹å‘çš„æœ€å°é—´è·?
            double minGap = double.MaxValue;

            // Xæ–¹å‘æŠ•å½±
            obstacles.Sort((a, b) => a.Left.CompareTo(b.Left));
            for (int i = 0; i < obstacles.Count - 1; i++)
            {
                double gap = obstacles[i + 1].Left - obstacles[i].Right;
                if (gap < minGap)
                {
                    minGap = gap;
                }
            }

            // Yæ–¹å‘æŠ•å½±
            obstacles.Sort((a, b) => a.Top.CompareTo(b.Top));
            for (int i = 0; i < obstacles.Count - 1; i++)
            {
                double gap = obstacles[i + 1].Top - obstacles[i].Bottom;
                if (gap < minGap)
                {
                    minGap = gap;
                }
            }

            return minGap;
        }

        /// <summary>
        /// è®¡ç®—å®‰å…¨è·ç¦»ï¼ˆåŸºäºéšœç¢æ•°é‡ï¼‰
        /// </summary>
        private double CalculateSafeDistance(int obstacleCount)
        {
            // åŸºç¡€è·ç¦» Ã— (1.0 + éšœç¢æ•°é‡ Ã— 0.1)
            double factor = 1.0 + obstacleCount * 0.1;
            double distance = BaseSafeDistance * factor;

            // å¦‚æœæœ‰éšœç¢ç‰©ï¼Œå¢åŠ é¢å¤–çš„å®‰å…¨è·ç¦»
            if (obstacleCount > 0)
            {
                distance += 10.0; // é¢å¤–çš„é¿éšœç©ºé—?
            }

            // é™åˆ¶åœ?5-60pxä¹‹é—´ï¼ˆæé«˜äº†ä¸Šé™ï¼?
            return Math.Clamp(distance, 15.0, MaxSafeDistance + 10.0);
        }

        /// <summary>
        /// ç”Ÿæˆæ™ºèƒ½è·¯å¾„ï¼ˆæœ€å°é—´è·æ–¹æ¡ˆï¼‰- ç®€åŒ–ç‰ˆæœ?
        /// </summary>
        private List<Point> GenerateSmartPath(PathContext context, PortCombinationType portCombo, 
            NodeRelativePosition relativePos, Point transitionPoint, double minGap, double safeDistance)
        {
            // ä½¿ç”¨ä¼˜åŒ–åçš„ç»Ÿä¸€è·¯å¾„ç”Ÿæˆ
            return GenerateUniversalPathFromTransition_Optimized(context, portCombo, relativePos, transitionPoint);
        }

        /// <summary>
        /// ç”Ÿæˆé€šç”¨è·¯å¾„ï¼ˆå…è®¸ç©¿è¿‡éšœç¢ï¼‰
        /// </summary>
        private List<Point> GenerateUniversalPathFromTransition(PathContext context, PortCombinationType portCombo,
            NodeRelativePosition relativePos, Point transitionPoint)
        {
            var path = new List<Point>();
            Point startPoint = context.StartPoint;
            Point endPoint = context.ArrowTailPoint;

            // å¦‚æœèµ·ç‚¹å’Œè¿‡æ¸¡ç‚¹ç›¸åŒï¼Œç›´æ¥ä»èµ·ç‚¹å¼€å§?
            Point actualStart = IsSamePoint(startPoint, transitionPoint) ? startPoint : transitionPoint;

            // ç”Ÿæˆç®€å•çš„æ­£äº¤è·¯å¾„ï¼ˆæœ€å¤?ä¸ªè½¬æŠ˜ç‚¹ï¼?
            switch (portCombo)
            {
                case PortCombinationType.LeftToRight:
                    // å·¦åˆ°å³ï¼šæ°´å¹³è¿æ¥
                    // è·¯å¾„ï¼šèµ·ç‚?è¿‡æ¸¡ç‚?â†?(ç»ˆç‚¹X, èµ·ç‚¹Y) â†?ç»ˆç‚¹
                    path.Add(new Point(endPoint.X, actualStart.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.RightToLeft:
                    // å³åˆ°å·¦ï¼šæ°´å¹³è¿æ¥
                    // è·¯å¾„ï¼šèµ·ç‚?è¿‡æ¸¡ç‚?â†?(ç»ˆç‚¹X, èµ·ç‚¹Y) â†?ç»ˆç‚¹
                    path.Add(new Point(endPoint.X, actualStart.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.TopToBottom:
                case PortCombinationType.BottomToTop:
                    // å‚ç›´è¿æ¥ï¼šèµ·ç‚?â†?(èµ·ç‚¹X, ç»ˆç‚¹Y) â†?ç»ˆç‚¹
                    path.Add(new Point(actualStart.X, endPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.LeftToTop:
                case PortCombinationType.LeftToBottom:
                    // å·¦ä¾§å‡ºå‘ï¼šå…ˆå‘å·¦æ°´å¹³ç§»åŠ¨ï¼Œå†å‚ç›´ç§»åŠ¨åˆ°ç»ˆç‚¹Y
                    // è·¯å¾„ï¼šèµ·ç‚?â†?è¿‡æ¸¡ç‚?â†?(è¿‡æ¸¡ç‚¹X, ç»ˆç‚¹Y) â†?ç»ˆç‚¹
                    path.Add(new Point(actualStart.X, endPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.RightToTop:
                case PortCombinationType.RightToBottom:
                    // å³ä¾§å‡ºå‘ï¼šå…ˆå‘å³æ°´å¹³ç§»åŠ¨ï¼Œå†å‚ç›´ç§»åŠ¨åˆ°ç»ˆç‚¹Y
                    path.Add(new Point(actualStart.X, endPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.TopToLeft:
                case PortCombinationType.TopToRight:
                    // é¡¶éƒ¨å‡ºå‘ï¼šå…ˆå‘ä¸Šå‚ç›´ç§»åŠ¨ï¼Œå†æ°´å¹³ç§»åŠ¨åˆ°ç»ˆç‚¹X
                    path.Add(new Point(endPoint.X, actualStart.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.BottomToLeft:
                case PortCombinationType.BottomToRight:
                    // åº•éƒ¨å‡ºå‘ï¼šå…ˆå‘ä¸‹å‚ç›´ç§»åŠ¨ï¼Œå†æ°´å¹³ç§»åŠ¨åˆ°ç»ˆç‚¹X
                    path.Add(new Point(endPoint.X, actualStart.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.LeftToLeft:
                    // å·¦åˆ°å·¦ï¼šå…ˆå‚ç›´ç§»åŠ¨é¿å¼€ï¼Œå†æ°´å¹³ç§»åŠ¨
                    path.Add(new Point(actualStart.X, endPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.RightToRight:
                    // å³åˆ°å³ï¼šå…ˆå‚ç›´ç§»åŠ¨é¿å¼€ï¼Œå†æ°´å¹³ç§»åŠ¨
                    path.Add(new Point(actualStart.X, endPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.TopToTop:
                    // é¡¶åˆ°é¡¶ï¼šå…ˆæ°´å¹³ç§»åŠ¨é¿å¼€ï¼Œå†å‚ç›´ç§»åŠ¨
                    path.Add(new Point(endPoint.X, actualStart.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.BottomToBottom:
                    // åº•åˆ°åº•ï¼šå…ˆæ°´å¹³ç§»åŠ¨é¿å¼€ï¼Œå†å‚ç›´ç§»åŠ¨
                    path.Add(new Point(endPoint.X, actualStart.Y));
                    path.Add(endPoint);
                    break;

                default:
                    // é»˜è®¤ï¼šä½¿ç”¨ç®€å•çš„Lå‹è·¯å¾?
                    if (relativePos == NodeRelativePosition.LeftOfTarget || 
                        relativePos == NodeRelativePosition.RightOfTarget)
                    {
                        // æ°´å¹³ä¼˜å…ˆ
                        path.Add(new Point(endPoint.X, actualStart.Y));
                        path.Add(endPoint);
                    }
                    else
                    {
                        // å‚ç›´ä¼˜å…ˆ
                        path.Add(new Point(actualStart.X, endPoint.Y));
                        path.Add(endPoint);
                    }
                    break;
            }

            return path;
        }

        /// <summary>
        /// ç”Ÿæˆæ°´å¹³è·¯å¾„ï¼ˆå…ˆç”Ÿæˆæ°´å¹³æ®µï¼Œå†ç”Ÿæˆå‚ç›´æ®µï¼?
        /// </summary>
        private List<Point> GenerateHorizontalPath(PathContext context, NodeRelativePosition relativePos,
            Point transitionPoint, double minGap, double safeDistance)
        {
            var path = new List<Point>();
            Point startPoint = context.StartPoint;
            Point endPoint = context.ArrowTailPoint;
            var obstacles = context.Obstacles;
            double pathY = 0; // å£°æ˜pathYå˜é‡ä¾›åç»­ä½¿ç”?
            double sourceTop = 0; // å£°æ˜sourceTopå˜é‡ä¾›åç»­ä½¿ç”?
            double sourceBottom = 0; // å£°æ˜sourceBottomå˜é‡ä¾›åç»­ä½¿ç”?
            double targetTop = 0; // å£°æ˜targetTopå˜é‡ä¾›åç»­ä½¿ç”?
            double targetBottom = 0; // å£°æ˜targetBottomå˜é‡ä¾›åç»­ä½¿ç”?
            bool pathYOverlapsSource = false; // å£°æ˜pathYOverlapsSourceå˜é‡ä¾›åç»­ä½¿ç”?
            bool pathYOverlapsTarget = false; // å£°æ˜pathYOverlapsTargetå˜é‡ä¾›åç»­ä½¿ç”?

            // è®¡ç®—æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„æ°´å¹³èŒƒå›?
            double sourceRight = context.SourceNode.Position.X + _config.NodeWidth;
            double sourceLeft = context.SourceNode.Position.X;
            double targetRight = context.TargetNode.Position.X + _config.NodeWidth;
            double targetLeft = context.TargetNode.Position.X;

            DebugHelper.WriteLine($"[GenerateHorizontalPath] æºèŠ‚ç‚¹XèŒƒå›´: [{sourceLeft:F1}, {sourceRight:F1}]");
            DebugHelper.WriteLine($"[GenerateHorizontalPath] ç›®æ ‡èŠ‚ç‚¹XèŒƒå›´: [{targetLeft:F1}, {targetRight:F1}]");
            DebugHelper.WriteLine($"[GenerateHorizontalPath] æºç«¯å£X: {startPoint.X:F1}, ç›®æ ‡ç«¯å£X: {endPoint.X:F1}");
            DebugHelper.WriteLine($"[GenerateHorizontalPath] å®‰å…¨è·ç¦»: {safeDistance:F1}");

            // è®¡ç®—æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´ï¼ˆåŠ ä¸Šå®‰å…¨è·ç¦»ï¼?
            double sourceLeftExtended = sourceLeft - safeDistance;
            double sourceRightExtended = sourceRight + safeDistance;

            // æ£€æŸ¥ç›®æ ‡ç«¯å£Xæ˜¯å¦åœ¨æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´å¤?
            bool targetXOutsideSourceRange = endPoint.X < sourceLeftExtended || endPoint.X > sourceRightExtended;
            DebugHelper.WriteLine($"[GenerateHorizontalPath] ç›®æ ‡ç«¯å£Xåœ¨æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´å¤? {targetXOutsideSourceRange}");

            // å¦‚æœç›®æ ‡ç«¯å£Xåœ¨æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´å¤–ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰éšœç¢ç‰©é˜»æŒ?
            if (targetXOutsideSourceRange)
            {
                DebugHelper.WriteLine($"[GenerateHorizontalPath] ç›®æ ‡ç«¯å£Xåœ¨æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´å¤?);

                // æ£€æŸ¥æ°´å¹³ç›´çº¿è·¯å¾„æ˜¯å¦ä¼šè¢«éšœç¢ç‰©é˜»æŒ¡
                bool pathBlocked = false;
                pathY = transitionPoint.Y;

                if (obstacles != null && obstacles.Count > 0)
                {
                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        double obsTop = obstacle.Position.Y;
                        double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                        // æ£€æŸ¥éšœç¢ç‰©æ˜¯å¦åœ¨æ°´å¹³è·¯å¾„çš„Yåæ ‡ä¸?
                        if (pathY >= obsTop - safeDistance && pathY <= obsBottom + safeDistance)
                        {
                            // è¿›ä¸€æ­¥æ£€æŸ¥æ°´å¹³è·¯å¾„æ˜¯å¦ä¼šç©¿è¿‡éšœç¢ç‰©çš„XèŒƒå›´
                            double obsLeft = obstacle.Position.X;
                            double obsRight = obstacle.Position.X + _config.NodeWidth;
                            double pathXStart = Math.Min(startPoint.X, endPoint.X);
                            double pathXEnd = Math.Max(startPoint.X, endPoint.X);

                            // å¦‚æœæ°´å¹³è·¯å¾„ä¸éšœç¢ç‰©åœ¨Xæ–¹å‘æœ‰äº¤é›†ï¼Œåˆ™è·¯å¾„è¢«é˜»æŒ¡
                            if (!(pathXEnd < obsLeft - safeDistance || pathXStart > obsRight + safeDistance))
                            {
                                pathBlocked = true;
                                DebugHelper.WriteLine($"[GenerateHorizontalPath] æ°´å¹³è·¯å¾„è¢«éšœç¢?{obstacle.Name} é˜»æŒ¡");
                                break;
                            }
                        }
                    }
                }

                if (!pathBlocked)
                {
                    DebugHelper.WriteLine($"[GenerateHorizontalPath] ä½¿ç”¨ç®€åŒ–è·¯å¾„ï¼šä¸­é—´ç‚¹X = ç›®æ ‡ç«¯å£X");

                    // è®¡ç®—æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„YèŒƒå›´
                    sourceTop = context.SourceNode.Position.Y;
                    sourceBottom = context.SourceNode.Position.Y + _config.NodeHeight;

                    // æ£€æŸ¥æ°´å¹³è·¯å¾„çš„Yåæ ‡æ˜¯å¦ä¼šç©¿è¿‡æºèŠ‚ç‚¹æˆ–ç›®æ ‡èŠ‚ç‚?
                    pathY = transitionPoint.Y;
                    pathYOverlapsSource = pathY >= sourceTop - safeDistance && pathY <= sourceBottom + safeDistance;
                    targetTop = context.TargetNode.Position.Y;
                    targetBottom = context.TargetNode.Position.Y + _config.NodeHeight;
                    pathYOverlapsTarget = pathY >= targetTop - safeDistance && pathY <= targetBottom + safeDistance;

                    if (pathYOverlapsSource || pathYOverlapsTarget)
                    {
                        DebugHelper.WriteLine($"[GenerateHorizontalPath] ç®€åŒ–è·¯å¾„Y={pathY:F1}ä¼šç©¿è¿‡èŠ‚ç‚¹ï¼Œä½¿ç”¨å¸¸è§„ç»•è¡Œè·¯å¾„");
                        // é€€å‡ºç®€åŒ–è·¯å¾„é€»è¾‘ï¼Œç»§ç»­æ‰§è¡Œå¸¸è§„è·¯å¾„ç”Ÿæˆ?
                    }
                    else
                    {
                        // ç®€åŒ–è·¯å¾„ï¼šè¿‡æ¸¡ç‚?â†?ä¸­é—´ç‚?ç›®æ ‡ç«¯å£X) â†?ç»ˆç‚¹
                        path.Add(new Point(endPoint.X, transitionPoint.Y));
                        path.Add(new Point(endPoint.X, endPoint.Y));
                        return path;
                    }
                }
                else
                {
                    DebugHelper.WriteLine($"[GenerateHorizontalPath] æ°´å¹³è·¯å¾„è¢«é˜»æŒ¡ï¼Œä½¿ç”¨å¸¸è§„ç»•è¡Œè·¯å¾„");
                }
            }

            // å¸¸è§„è·¯å¾„ï¼šéœ€è¦è®¡ç®—é¿å¼€æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„ä¸­é—´Xåæ ‡
            DebugHelper.WriteLine($"[GenerateHorizontalPath] ä½¿ç”¨å¸¸è§„è·¯å¾„ï¼šéœ€è¦é¿å¼€èŠ‚ç‚¹");

            // æ ¹æ®èŠ‚ç‚¹ç›¸å¯¹ä½ç½®é€‰æ‹©ä¸­é—´Xåæ ‡ï¼ˆä½¿ç”¨èŠ‚ç‚¹ä¸­å¿ƒç‚¹æ¯”è¾ƒï¼?
            double midX;
            double sourceCenterX = (sourceLeft + sourceRight) / 2;
            double targetCenterX = (targetLeft + targetRight) / 2;
            bool targetNodeRightOfSource = targetCenterX > sourceCenterX;

            // è®¡ç®—ä¸¤ä¸ªèŠ‚ç‚¹çš„å¹¶é›†èŒƒå›?
            double unionLeft = Math.Min(sourceLeft, targetLeft);
            double unionRight = Math.Max(sourceRight, targetRight);

            // æ ¹æ®ç›®æ ‡ç«¯å£ç›¸å¯¹äºæºç«¯å£çš„ä½ç½®é€‰æ‹©ç§»åŠ¨æ–¹å‘
            if (endPoint.X <= sourceCenterX)
            {
                // ç›®æ ‡ç«¯å£åœ¨æºç«¯å£å·¦ä¾§æˆ–åŒä¸€ä½ç½®ï¼šå‘å·¦ç§»åŠ?
                midX = Math.Min(targetRight, sourceLeft - safeDistance);
                DebugHelper.WriteLine($"[GenerateHorizontalPath] ç›®æ ‡ç«¯å£åœ¨æºç«¯å£å·¦ä¾§ï¼ŒmidXåˆå§‹å€? {midX:F1}");

                // å¦‚æœmidXåœ¨æºæˆ–ç›®æ ‡èŒƒå›´å†…ï¼Œè°ƒæ•´åˆ°å·¦ä¾§
                if (midX >= sourceLeft - safeDistance && midX <= sourceRight + safeDistance ||
                    midX >= targetLeft - safeDistance && midX <= targetRight + safeDistance)
                {
                    midX = unionLeft - safeDistance;
                    DebugHelper.WriteLine($"[GenerateHorizontalPath] è°ƒæ•´midXåˆ°èŠ‚ç‚¹å·¦ä¾? {midX:F1}");
                }
            }
            else
            {
                // ç›®æ ‡ç«¯å£åœ¨æºç«¯å£å³ä¾§ï¼šå‘å³ç§»åŠ?
                midX = Math.Max(sourceRight, targetLeft - safeDistance);
                DebugHelper.WriteLine($"[GenerateHorizontalPath] ç›®æ ‡ç«¯å£åœ¨æºç«¯å£å³ä¾§ï¼ŒmidXåˆå§‹å€? {midX:F1}");

                // å¦‚æœmidXåœ¨æºæˆ–ç›®æ ‡èŒƒå›´å†…ï¼Œè°ƒæ•´åˆ°å³ä¾§
                if (midX >= sourceLeft - safeDistance && midX <= sourceRight + safeDistance ||
                    midX >= targetLeft - safeDistance && midX <= targetRight + safeDistance)
                {
                    midX = unionRight + safeDistance;
                    DebugHelper.WriteLine($"[GenerateHorizontalPath] è°ƒæ•´midXåˆ°èŠ‚ç‚¹å³ä¾? {midX:F1}");
                }
            }

            // æ£€æŸ¥æ°´å¹³è·¯å¾„æ˜¯å¦ä¼šç©¿è¿‡éšœç¢ç‰?
            if (obstacles != null && obstacles.Count > 0)
            {
                bool midXBlocked = false;

                foreach (var obstacle in obstacles)
                {
                    if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                        continue;

                    double obsLeft = obstacle.Position.X;
                    double obsRight = obstacle.Position.X + _config.NodeWidth;

                    // æ£€æŸ¥éšœç¢ç‰©æ˜¯å¦åœ¨æ°´å¹³è·¯å¾„ä¸Š
                    if (midX >= obsLeft - safeDistance && midX <= obsRight + safeDistance)
                    {
                        midXBlocked = true;
                        break;
                    }
                }

                if (midXBlocked)
                {
                    DebugHelper.WriteLine($"[GenerateHorizontalPath] æ°´å¹³è·¯å¾„è¢«éšœç¢ç‰©é˜»æŒ¡ï¼Œå°è¯•è°ƒæ•?);

                    // å°è¯•å¦ä¸€ä¸ªæ–¹å‘ï¼ˆæ ¹æ®åŸé€‰æ‹©çš„åæ–¹å‘ï¼?
                    if (endPoint.X > sourceCenterX)
                    {
                        // åŸæœ¬å‘å³ç§»åŠ¨ï¼Œå°è¯•å‘å·?
                        double leftX = unionLeft - safeDistance;
                        bool leftBlocked = false;

                        foreach (var obstacle in obstacles)
                        {
                            if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                                continue;

                            double obsLeft = obstacle.Position.X;
                            double obsRight = obstacle.Position.X + _config.NodeWidth;

                            if (leftX >= obsLeft - safeDistance && leftX <= obsRight + safeDistance)
                            {
                                leftBlocked = true;
                                break;
                            }
                        }

                        if (!leftBlocked)
                        {
                            midX = leftX;
                            DebugHelper.WriteLine($"[GenerateHorizontalPath] è°ƒæ•´åˆ°å·¦ä¾§è·¯å¾? {midX:F1}");
                        }
                    }
                    else
                    {
                        // åŸæœ¬å‘å·¦ç§»åŠ¨ï¼Œå°è¯•å‘å?
                        double rightX = unionRight + safeDistance;
                        bool rightBlocked = false;

                        foreach (var obstacle in obstacles)
                        {
                            if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                                continue;

                            double obsLeft = obstacle.Position.X;
                            double obsRight = obstacle.Position.X + _config.NodeWidth;

                            if (rightX >= obsLeft - safeDistance && rightX <= obsRight + safeDistance)
                            {
                                rightBlocked = true;
                                break;
                            }
                        }

                        if (!rightBlocked)
                        {
                            midX = rightX;
                            DebugHelper.WriteLine($"[GenerateHorizontalPath] è°ƒæ•´åˆ°å³ä¾§è·¯å¾? {midX:F1}");
                        }
                    }
                }
            }

            DebugHelper.WriteLine($"[GenerateHorizontalPath] æœ€ç»ˆmidX: {midX:F1}");

            // è®¡ç®—æ°´å¹³è·¯å¾„çš„å®‰å…¨Yåæ ‡
            pathY = transitionPoint.Y;
            targetTop = context.TargetNode.Position.Y;
            targetBottom = context.TargetNode.Position.Y + _config.NodeHeight;

            // è·å–æºèŠ‚ç‚¹YèŒƒå›´
            sourceTop = context.SourceNode.Position.Y;
            sourceBottom = context.SourceNode.Position.Y + _config.NodeHeight;

            // æ£€æŸ¥æ°´å¹³è·¯å¾„çš„Yåæ ‡æ˜¯å¦ä¸æºèŠ‚ç‚¹æˆ–ç›®æ ‡èŠ‚ç‚¹YèŒƒå›´é‡å 
            pathYOverlapsSource = pathY >= sourceTop - safeDistance && pathY <= sourceBottom + safeDistance;
            pathYOverlapsTarget = pathY >= targetTop - safeDistance && pathY <= targetBottom + safeDistance;

            if (pathYOverlapsSource || pathYOverlapsTarget)
            {
                DebugHelper.WriteLine($"[GenerateHorizontalPath] æ°´å¹³è·¯å¾„Y={pathY:F1} éœ€è¦è°ƒæ•´ï¼ˆæºèŠ‚ç‚¹[{sourceTop:F1},{sourceBottom:F1}], ç›®æ ‡èŠ‚ç‚¹[{targetTop:F1},{targetBottom:F1}]ï¼?);

                // è®¡ç®—éšœç¢ç‰©çš„æœ€å°å’Œæœ€å¤§Yåæ ‡
                double minObsY = double.MaxValue;
                double maxObsY = double.MinValue;

                if (obstacles != null && obstacles.Count > 0)
                {
                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        minObsY = Math.Min(minObsY, obstacle.Position.Y);
                        maxObsY = Math.Max(maxObsY, obstacle.Position.Y + _config.NodeHeight);
                    }
                }

                // è®¡ç®—æ‰€æœ‰éœ€è¦é¿å¼€çš„èŠ‚ç‚¹çš„æœ€å°å’Œæœ€å¤§Yåæ ‡ï¼ˆåŒ…æ‹¬æºèŠ‚ç‚¹ã€ç›®æ ‡èŠ‚ç‚¹å’Œéšœç¢ç‰©ï¼‰
                double allMinY = Math.Min(Math.Min(sourceTop, targetTop), minObsY);
                double allMaxY = Math.Max(Math.Max(sourceBottom, targetBottom), maxObsY);

                // è®¡ç®—å®‰å…¨çš„Yåæ ‡ï¼ˆåœ¨æ‰€æœ‰èŠ‚ç‚¹YèŒƒå›´ä¹‹å¤–ï¼?
                double pathYAbove = allMinY - safeDistance - 20;
                double pathYBelow = allMaxY + safeDistance + 20;

                // é€‰æ‹©è·ç¦»æºç«¯å£Yæ›´è¿‘çš„Yåæ ‡
                double sourcePortY = context.StartPoint.Y;
                if (Math.Abs(pathYAbove - sourcePortY) < Math.Abs(pathYBelow - sourcePortY))
                {
                    pathY = pathYAbove;
                    DebugHelper.WriteLine($"[GenerateHorizontalPath] è°ƒæ•´æ°´å¹³è·¯å¾„Yåˆ°ä¸Šæ–? {pathY:F1}");
                }
                else
                {
                    pathY = pathYBelow;
                    DebugHelper.WriteLine($"[GenerateHorizontalPath] è°ƒæ•´æ°´å¹³è·¯å¾„Yåˆ°ä¸‹æ–? {pathY:F1}");
                }

                // ç”Ÿæˆä¸‰æ®µè·¯å¾„ï¼šå…ˆå‚ç›´ç§»åŠ¨åˆ°å®‰å…¨çš„Yåæ ‡ï¼Œå†æ°´å¹³ç§»åŠ¨ï¼Œæœ€åå‚ç›´ç§»åŠ¨åˆ°ç»ˆç‚¹
                path.Add(new Point(transitionPoint.X, pathY));
                path.Add(new Point(midX, pathY));
                path.Add(new Point(midX, endPoint.Y));
                path.Add(new Point(endPoint.X, endPoint.Y));
                return path;
            }

            // ç¬¬ä¸€æ®µï¼šä»è¿‡æ¸¡ç‚¹æ°´å¹³ç§»åŠ¨åˆ°ä¸­é—´X
            Point midPoint1 = new Point(midX, transitionPoint.Y);
            path.Add(midPoint1);

            // ç¬¬äºŒæ®µï¼šå‚ç›´ç§»åŠ¨åˆ°ç»ˆç‚¹Yï¼ˆè¿™æ˜¯ç¬¬äºŒä¸ªç›´è§’è½¬æŠ˜ï¼?
            Point midPoint2 = new Point(midX, endPoint.Y);
            path.Add(midPoint2);

            // æ·»åŠ æœ€ç»ˆè°ƒæ•´ç‚¹ï¼Œç¡®ä¿ç›´è§’æŠ˜çº¿ï¼ˆæ€»æ˜¯æ·»åŠ ï¼Œä¿è¯ä¸¤ä¸ªè¿‡æ¸¡ç‚¹ï¼?
            path.Add(new Point(endPoint.X, endPoint.Y));

            return path;
        }

        /// <summary>
        /// ç”Ÿæˆå‚ç›´è·¯å¾„ï¼ˆå…ˆç”Ÿæˆå‚ç›´æ®µï¼Œå†ç”Ÿæˆæ°´å¹³æ®µï¼?
        /// </summary>
        private List<Point> GenerateVerticalPath(PathContext context, NodeRelativePosition relativePos,
            Point transitionPoint, double minGap, double safeDistance)
        {
            var path = new List<Point>();
            Point startPoint = context.StartPoint;
            Point endPoint = context.ArrowTailPoint;
            var obstacles = context.Obstacles;

            // è®¡ç®—æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„å‚ç›´èŒƒå›?
            double sourceBottom = context.SourceNode.Position.Y + _config.NodeHeight;
            double sourceTop = context.SourceNode.Position.Y;
            double targetBottom = context.TargetNode.Position.Y + _config.NodeHeight;
            double targetTop = context.TargetNode.Position.Y;

            DebugHelper.WriteLine($"[GenerateVerticalPath] æºèŠ‚ç‚¹YèŒƒå›´: [{sourceTop:F1}, {sourceBottom:F1}]");
            DebugHelper.WriteLine($"[GenerateVerticalPath] ç›®æ ‡èŠ‚ç‚¹YèŒƒå›´: [{targetTop:F1}, {targetBottom:F1}]");
            DebugHelper.WriteLine($"[GenerateVerticalPath] æºç«¯å£Y: {startPoint.Y:F1}, ç›®æ ‡ç«¯å£Y: {endPoint.Y:F1}");
            DebugHelper.WriteLine($"[GenerateVerticalPath] å®‰å…¨è·ç¦»: {safeDistance:F1}");

            // è®¡ç®—æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´ï¼ˆåŠ ä¸Šå®‰å…¨è·ç¦»ï¼?
            double sourceTopExtended = sourceTop - safeDistance;
            double sourceBottomExtended = sourceBottom + safeDistance;

            // æ£€æŸ¥ç›®æ ‡ç«¯å£Yæ˜¯å¦åœ¨æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´å¤?
            bool targetYOutsideSourceRange = endPoint.Y < sourceTopExtended || endPoint.Y > sourceBottomExtended;
            DebugHelper.WriteLine($"[GenerateVerticalPath] ç›®æ ‡ç«¯å£Yåœ¨æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´å¤? {targetYOutsideSourceRange}");

            // å¦‚æœç›®æ ‡ç«¯å£Yåœ¨æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´å¤–ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰éšœç¢ç‰©é˜»æŒ?
            if (targetYOutsideSourceRange)
            {
                DebugHelper.WriteLine($"[GenerateVerticalPath] ç›®æ ‡ç«¯å£Yåœ¨æºèŠ‚ç‚¹æ‰©å±•èŒƒå›´å¤?);

                // æ£€æŸ¥å‚ç›´ç›´çº¿è·¯å¾„æ˜¯å¦ä¼šè¢«éšœç¢ç‰©é˜»æŒ¡
                bool pathBlocked = false;
                double pathX = transitionPoint.X;

                if (obstacles != null && obstacles.Count > 0)
                {
                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        double obsLeft = obstacle.Position.X;
                        double obsRight = obstacle.Position.X + _config.NodeWidth;

                        // æ£€æŸ¥éšœç¢ç‰©æ˜¯å¦åœ¨å‚ç›´è·¯å¾„çš„Xåæ ‡ä¸?
                        if (pathX >= obsLeft - safeDistance && pathX <= obsRight + safeDistance)
                        {
                            // è¿›ä¸€æ­¥æ£€æŸ¥å‚ç›´è·¯å¾„æ˜¯å¦ä¼šç©¿è¿‡éšœç¢ç‰©çš„YèŒƒå›´
                            double obsTop = obstacle.Position.Y;
                            double obsBottom = obstacle.Position.Y + _config.NodeHeight;
                            double pathYStart = Math.Min(startPoint.Y, endPoint.Y);
                            double pathYEnd = Math.Max(startPoint.Y, endPoint.Y);

                            // å¦‚æœå‚ç›´è·¯å¾„ä¸éšœç¢ç‰©åœ¨Yæ–¹å‘æœ‰äº¤é›†ï¼Œåˆ™è·¯å¾„è¢«é˜»æŒ¡
                            if (!(pathYEnd < obsTop - safeDistance || pathYStart > obsBottom + safeDistance))
                            {
                                pathBlocked = true;
                                DebugHelper.WriteLine($"[GenerateVerticalPath] å‚ç›´è·¯å¾„è¢«éšœç¢?{obstacle.Name} é˜»æŒ¡");
                                break;
                            }
                        }
                    }
                }

                if (!pathBlocked)
                {
                    DebugHelper.WriteLine($"[GenerateVerticalPath] ä½¿ç”¨ç®€åŒ–è·¯å¾„ï¼šä¸­é—´ç‚¹Y = ç›®æ ‡ç«¯å£Y");

                    // è®¡ç®—æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„XèŒƒå›´
                    double sourceLeft = context.SourceNode.Position.X;
                    double sourceRight = context.SourceNode.Position.X + _config.NodeWidth;
                    double targetLeft = context.TargetNode.Position.X;
                    double targetRight = context.TargetNode.Position.X + _config.NodeWidth;

                    // æ£€æŸ¥å‚ç›´è·¯å¾„çš„Xåæ ‡æ˜¯å¦ä¼šç©¿è¿‡æºèŠ‚ç‚¹æˆ–ç›®æ ‡èŠ‚ç‚?
                    pathX = transitionPoint.X;
                    bool pathXOverlapsSource = pathX >= sourceLeft - safeDistance && pathX <= sourceRight + safeDistance;
                    bool pathXOverlapsTarget = pathX >= targetLeft - safeDistance && pathX <= targetRight + safeDistance;

                    if (pathXOverlapsSource || pathXOverlapsTarget)
                    {
                        DebugHelper.WriteLine($"[GenerateVerticalPath] ç®€åŒ–è·¯å¾„X={pathX:F1}ä¼šç©¿è¿‡èŠ‚ç‚¹ï¼Œä½¿ç”¨å¸¸è§„ç»•è¡Œè·¯å¾„");
                        // é€€å‡ºç®€åŒ–è·¯å¾„é€»è¾‘ï¼Œç»§ç»­æ‰§è¡Œå¸¸è§„è·¯å¾„ç”Ÿæˆ?
                    }
                    else
                    {
                        // ç®€åŒ–è·¯å¾„ï¼šè¿‡æ¸¡ç‚?â†?ä¸­é—´ç‚?ç›®æ ‡ç«¯å£Y) â†?ç»ˆç‚¹
                        path.Add(new Point(transitionPoint.X, endPoint.Y));
                        path.Add(new Point(endPoint.X, endPoint.Y));
                        return path;
                    }
                }
                else
                {
                    DebugHelper.WriteLine($"[GenerateVerticalPath] å‚ç›´è·¯å¾„è¢«é˜»æŒ¡ï¼Œä½¿ç”¨å¸¸è§„ç»•è¡Œè·¯å¾„");
                }
            }

            // å¸¸è§„è·¯å¾„ï¼šéœ€è¦è®¡ç®—é¿å¼€æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹çš„ä¸­é—´Yåæ ‡
            DebugHelper.WriteLine($"[GenerateVerticalPath] ä½¿ç”¨å¸¸è§„è·¯å¾„ï¼šéœ€è¦é¿å¼€èŠ‚ç‚¹");

            // è®¡ç®—ç›®æ ‡èŠ‚ç‚¹ç›¸å¯¹äºæºèŠ‚ç‚¹çš„ä½ç½®å…³ç³?
            bool targetAboveSource = targetBottom <= sourceTop;
            bool targetBelowSource = targetTop >= sourceBottom;
            bool verticallyOverlapping = !targetAboveSource && !targetBelowSource;

            DebugHelper.WriteLine($"[GenerateVerticalPath] ç›®æ ‡èŠ‚ç‚¹ä½ç½®å…³ç³»: åœ¨æºèŠ‚ç‚¹ä¸Šæ–¹={targetAboveSource}, åœ¨æºèŠ‚ç‚¹ä¸‹æ–¹={targetBelowSource}, å‚ç›´é‡å ={verticallyOverlapping}");

            // è®¡ç®—ä¸¤ä¸ªèŠ‚ç‚¹çš„å¹¶é›†èŒƒå›?
            double unionTop = Math.Min(sourceTop, targetTop);
            double unionBottom = Math.Max(sourceBottom, targetBottom);

            // æ ¹æ®ç›®æ ‡èŠ‚ç‚¹ç›¸å¯¹äºæºèŠ‚ç‚¹çš„ä½ç½®å†³å®šç»•è¡Œæ–¹å?
            double midY;
            bool goAbove;

            if (targetAboveSource)
            {
                // ç›®æ ‡èŠ‚ç‚¹åœ¨æºèŠ‚ç‚¹ä¸Šæ–¹ï¼Œå‘ä¸Šæ–¹ç»•è¡Œ
                midY = unionTop - safeDistance;
                goAbove = true;
                DebugHelper.WriteLine($"[GenerateVerticalPath] ç›®æ ‡åœ¨æºèŠ‚ç‚¹ä¸Šæ–¹ï¼Œå‘ä¸Šæ–¹ç»•è¡Œ, midY: {midY:F1}");
            }
            else if (targetBelowSource)
            {
                // ç›®æ ‡èŠ‚ç‚¹åœ¨æºèŠ‚ç‚¹ä¸‹æ–¹ï¼Œå‘ä¸‹æ–¹ç»•è¡Œ
                midY = unionBottom + safeDistance;
                goAbove = false;
                DebugHelper.WriteLine($"[GenerateVerticalPath] ç›®æ ‡åœ¨æºèŠ‚ç‚¹ä¸‹æ–¹ï¼Œå‘ä¸‹æ–¹ç»•è¡Œ, midY: {midY:F1}");
            }
            else
            {
                // å‚ç›´é‡å ï¼Œæ ¹æ®éšœç¢ç‰©åˆ†å¸ƒä½œä¸ºæ¬¡è¦åˆ¤æ–­ä¾æ®
                int obstaclesAbove = 0;
                int obstaclesBelow = 0;

                if (obstacles != null && obstacles.Count > 0)
                {
                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        double obsTop = obstacle.Position.Y;
                        double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                        // ç»Ÿè®¡éšœç¢ç‰©åˆ†å¸?
                        if (obsBottom < sourceTop)
                        {
                            obstaclesAbove++;
                        }
                        else if (obsTop > sourceBottom)
                        {
                            obstaclesBelow++;
                        }
                    }
                }

                goAbove = obstaclesBelow > obstaclesAbove;

                if (goAbove)
                {
                    midY = unionTop - safeDistance;
                    DebugHelper.WriteLine($"[GenerateVerticalPath] å‚ç›´é‡å ï¼Œå‘ä¸Šæ–¹ç»•è¡Œï¼ˆä¸‹æ–¹éšœç¢æ›´å¤šï¼‰, midY: {midY:F1}");
                }
                else
                {
                    midY = unionBottom + safeDistance;
                    DebugHelper.WriteLine($"[GenerateVerticalPath] å‚ç›´é‡å ï¼Œå‘ä¸‹æ–¹ç»•è¡Œï¼ˆä¸Šæ–¹éšœç¢æ›´å¤šï¼‰, midY: {midY:F1}");
                }
            }

            // éªŒè¯é€‰å®šè·¯å¾„æ˜¯å¦è¢«éšœç¢ç‰©é˜»æŒ¡
            if (obstacles != null && obstacles.Count > 0)
            {
                bool pathBlocked = false;
                foreach (var obstacle in obstacles)
                {
                    if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                        continue;

                    double obsTop = obstacle.Position.Y;
                    double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                    if (midY >= obsTop - safeDistance && midY <= obsBottom + safeDistance)
                    {
                        pathBlocked = true;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] âš ï¸ è·¯å¾„è¢«éšœç¢?{obstacle.Name} é˜»æŒ¡");
                        break;
                    }
                }

                if (pathBlocked)
                {
                    // åˆå§‹è·¯å¾„å—é˜»ï¼Œå°è¯•ç›¸åæ–¹å?
                    if (goAbove)
                    {
                        midY = unionBottom + safeDistance;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] åˆ‡æ¢åˆ°ä¸‹æ–¹ç»•è¡? midY: {midY:F1}");
                    }
                    else
                    {
                        midY = unionTop - safeDistance;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] åˆ‡æ¢åˆ°ä¸Šæ–¹ç»•è¡? midY: {midY:F1}");
                    }

                    // äºŒæ¬¡éªŒè¯
                    bool bothSidesBlocked = false;
                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        double obsTop = obstacle.Position.Y;
                        double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                        if (midY >= obsTop - safeDistance && midY <= obsBottom + safeDistance)
                        {
                            bothSidesBlocked = true;
                            DebugHelper.WriteLine($"[GenerateVerticalPath] âš ï¸ ç›¸åæ–¹å‘ä¹Ÿè¢«éšœç¢ {obstacle.Name} é˜»æŒ¡");
                            break;
                        }
                    }

                    if (bothSidesBlocked)
                    {
                        // åŒå‘å—é˜»ï¼Œç”Ÿæˆæ°´å¹³ç»•è¡Œè·¯å¾„ï¼ˆä»å·¦ä¾§æˆ–å³ä¾§ç»•è¿‡ï¼?
                        DebugHelper.WriteLine($"[GenerateVerticalPath] åŒå‘å—é˜»ï¼Œç”Ÿæˆæ°´å¹³ç»•è¡Œè·¯å¾?);

                        // è®¡ç®—éšœç¢ç‰©çš„æœ€å°å’Œæœ€å¤§Xåæ ‡ï¼Œä»¥åŠæœ€å°å’Œæœ€å¤§Yåæ ‡
                        double minObsX = double.MaxValue;
                        double maxObsX = double.MinValue;
                        double minObsY = double.MaxValue;
                        double maxObsY = double.MinValue;

                        foreach (var obstacle in obstacles)
                        {
                            if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                                continue;

                            minObsX = Math.Min(minObsX, obstacle.Position.X);
                            maxObsX = Math.Max(maxObsX, obstacle.Position.X + _config.NodeWidth);
                            minObsY = Math.Min(minObsY, obstacle.Position.Y);
                            maxObsY = Math.Max(maxObsY, obstacle.Position.Y + _config.NodeHeight);
                        }

                        // è®¡ç®—å·¦ä¾§å’Œå³ä¾§é€šè¿‡ä½ç½®
                        double leftX = minObsX - safeDistance - 20;
                        double rightX = maxObsX + safeDistance + 20;

                        // é€‰æ‹©è·ç¦»ç›®æ ‡æ›´è¿‘çš„ä¸€ä¾?
                        double bypassX = (Math.Abs(leftX - endPoint.X) < Math.Abs(rightX - endPoint.X)) ? leftX : rightX;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] æ°´å¹³ç»•è¡ŒX={bypassX:F1}");

                        // è®¡ç®—å®‰å…¨çš„æ°´å¹³ç»•è¡ŒYåæ ‡ï¼ˆåœ¨æ‰€æœ‰éšœç¢ç‰©YèŒƒå›´ä¹‹å¤–ï¼?
                        // å°è¯•ä¸Šæ–¹ç»•è¡Œ
                        double bypassYAbove = minObsY - safeDistance - 20;
                        double bypassYBelow = maxObsY + safeDistance + 20;

                        // é€‰æ‹©è·ç¦»èµ·ç‚¹å’Œç»ˆç‚¹Yéƒ½æ›´è¿‘çš„Yåæ ‡
                        double bypassY;
                        double midPathY = (startPoint.Y + endPoint.Y) / 2;
                        if (Math.Abs(bypassYAbove - midPathY) < Math.Abs(bypassYBelow - midPathY))
                        {
                            bypassY = bypassYAbove;
                            DebugHelper.WriteLine($"[GenerateVerticalPath] æ°´å¹³ç»•è¡ŒYï¼ˆä¸Šæ–¹ï¼‰={bypassY:F1}");
                        }
                        else
                        {
                            bypassY = bypassYBelow;
                            DebugHelper.WriteLine($"[GenerateVerticalPath] æ°´å¹³ç»•è¡ŒYï¼ˆä¸‹æ–¹ï¼‰={bypassY:F1}");
                        }

                        // ç”Ÿæˆæ°´å¹³ç»•è¡Œè·¯å¾„ï¼ˆä»å·¦ä¾§æˆ–å³ä¾§ç»•è¿‡æ‰€æœ‰éšœç¢ç‰©ï¼‰ï¼š
                        // 1. ä»è¿‡æ¸¡ç‚¹å‚ç›´ç§»åŠ¨åˆ°ç»•è¡ŒY
                        path.Add(new Point(transitionPoint.X, bypassY));
                        // 2. æ°´å¹³ç§»åŠ¨åˆ°ç»•è¡ŒX
                        path.Add(new Point(bypassX, bypassY));
                        // 3. å‚ç›´ç§»åŠ¨åˆ°ç›®æ ‡Y
                        path.Add(new Point(bypassX, endPoint.Y));
                        // 4. æ°´å¹³ç§»åŠ¨åˆ°ç›®æ ‡X
                        path.Add(endPoint);
                        return path;
                    }
                }
            }

            // æ£€æŸ¥å‚ç›´è·¯å¾„æ˜¯å¦ä¼šç©¿è¿‡éšœç¢ç‰©ï¼ˆé¢å¤–éªŒè¯ï¼?
            if (obstacles != null && obstacles.Count > 0)
            {
                bool midYBlocked = false;

                foreach (var obstacle in obstacles)
                {
                    if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                        continue;

                    double obsTop = obstacle.Position.Y;
                    double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                    // æ£€æŸ¥éšœç¢ç‰©æ˜¯å¦åœ¨å‚ç›´è·¯å¾„ä¸Š
                    if (midY >= obsTop - safeDistance && midY <= obsBottom + safeDistance)
                    {
                        midYBlocked = true;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] ä¸­é—´ç‚¹Y={midY:F1} è¢«éšœç¢?{obstacle.Name} (Y=[{obsTop:F1}, {obsBottom:F1}]) é˜»æŒ¡");
                        break;
                    }
                }

                if (midYBlocked)
                {
                    DebugHelper.WriteLine($"[GenerateVerticalPath] å‚ç›´è·¯å¾„è¢«éšœç¢ç‰©é˜»æŒ¡ï¼Œå°è¯•è°ƒæ•?);

                    double sourceCenterY = (sourceTop + sourceBottom) / 2;

                    // å°è¯•å¦ä¸€ä¸ªæ–¹å‘ï¼ˆæ ¹æ®åŸé€‰æ‹©çš„åæ–¹å‘ï¼?
                    if (endPoint.Y > sourceCenterY)
                    {
                        // åŸæœ¬å‘ä¸‹ç§»åŠ¨ï¼Œå°è¯•å‘ä¸?
                        double aboveY = unionTop - safeDistance;
                        bool aboveBlocked = false;

                        foreach (var obstacle in obstacles)
                        {
                            if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                                continue;

                            double obsTop = obstacle.Position.Y;
                            double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                            if (aboveY >= obsTop - safeDistance && aboveY <= obsBottom + safeDistance)
                            {
                                aboveBlocked = true;
                                DebugHelper.WriteLine($"[GenerateVerticalPath] ä¸Šæ–¹è·¯å¾„ {aboveY:F1} ä»è¢«éšœç¢ {obstacle.Name} é˜»æŒ¡");
                                break;
                            }
                        }

                        if (!aboveBlocked)
                        {
                            midY = aboveY;
                            DebugHelper.WriteLine($"[GenerateVerticalPath] è°ƒæ•´åˆ°ä¸Šæ–¹è·¯å¾? {midY:F1}");
                        }
                    }
                    else
                    {
                        // åŸæœ¬å‘ä¸Šç§»åŠ¨ï¼Œå°è¯•å‘ä¸?
                        double belowY = unionBottom + safeDistance;
                        bool belowBlocked = false;

                        foreach (var obstacle in obstacles)
                        {
                            if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                                continue;

                            double obsTop = obstacle.Position.Y;
                            double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                            if (belowY >= obsTop - safeDistance && belowY <= obsBottom + safeDistance)
                            {
                                belowBlocked = true;
                                DebugHelper.WriteLine($"[GenerateVerticalPath] ä¸‹æ–¹è·¯å¾„ {belowY:F1} ä»è¢«éšœç¢ {obstacle.Name} é˜»æŒ¡");
                                break;
                            }
                        }

                        if (!belowBlocked)
                        {
                            midY = belowY;
                            DebugHelper.WriteLine($"[GenerateVerticalPath] è°ƒæ•´åˆ°ä¸‹æ–¹è·¯å¾? {midY:F1}");
                        }
                    }
                }

                // é¢å¤–æ£€æŸ¥ï¼šéªŒè¯æœ€åä¸€æ®µå‚ç›´çº¿æ®µæ˜¯å¦ç©¿è¿‡éšœç¢ç‰©
                bool finalSegmentBlocked = false;
                foreach (var obstacle in obstacles)
                {
                    if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                        continue;

                    double obsLeft = obstacle.Position.X;
                    double obsRight = obstacle.Position.X + _config.NodeWidth;
                    double obsTop = obstacle.Position.Y;
                    double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                    // æ£€æŸ¥æœ€åä¸€æ®µå‚ç›´çº¿æ®?(transitionPoint.X, midY) -> (endPoint.X, endPoint.Y)
                    // å‚ç›´çº¿æ®µçš„Xåæ ‡æ˜?endPoint.X
                    // æ£€æŸ¥è¿™ä¸ªXåæ ‡æ˜¯å¦åœ¨éšœç¢èŠ‚ç‚¹çš„æ°´å¹³èŒƒå›´å†…ï¼ˆè€ƒè™‘å®‰å…¨è·ç¦»ï¼?
                    double finalExpandedMargin = safeDistance + _config.PathOffset;
                    bool xInObsRange = endPoint.X >= obsLeft - finalExpandedMargin && endPoint.X <= obsRight + finalExpandedMargin;

                    if (xInObsRange)
                    {
                        // å‚ç›´çº¿æ®µåœ¨éšœç¢èŠ‚ç‚¹çš„æ°´å¹³èŒƒå›´å†…ï¼Œæ£€æŸ¥Yåæ ‡æ˜¯å¦ä¸éšœç¢èŠ‚ç‚¹ç›¸äº?
                        bool yOverlap = !(Math.Max(midY, endPoint.Y) < obsTop - finalExpandedMargin ||
                                          Math.Min(midY, endPoint.Y) > obsBottom + finalExpandedMargin);

                        if (yOverlap)
                        {
                            finalSegmentBlocked = true;
                            DebugHelper.WriteLine($"[GenerateVerticalPath] âš ï¸ æœ€åä¸€æ®µå‚ç›´çº¿æ®µå°†ç©¿è¿‡éšœç¢ {obstacle.Name}");
                            DebugHelper.WriteLine($"[GenerateVerticalPath]   çº¿æ®µ: ({endPoint.X:F1}, {midY:F1} -> {endPoint.X:F1}, {endPoint.Y:F1})");
                            DebugHelper.WriteLine($"[GenerateVerticalPath]   éšœç¢: X=[{obsLeft:F1}, {obsRight:F1}], Y=[{obsTop:F1}, {obsBottom:F1}]");
                            DebugHelper.WriteLine($"[GenerateVerticalPath]   Xåœ¨éšœç¢èŒƒå›´å†…ï¼ˆå«å®‰å…¨è·ç¦»ï¼? {xInObsRange}");
                            DebugHelper.WriteLine($"[GenerateVerticalPath]   Yä¸éšœç¢é‡å? {yOverlap}");
                            break;
                        }
                    }
                }

                if (finalSegmentBlocked)
                {
                    DebugHelper.WriteLine($"[GenerateVerticalPath] æœ€åä¸€æ®µå‚ç›´çº¿æ®µè¢«é˜»æŒ¡ï¼Œå°è¯•å®Œå…¨é¿å¼€éšœç¢");

                    // å°è¯•åœ¨éšœç¢èŠ‚ç‚¹çš„XèŒƒå›´ä¹‹å¤–é€šè¿‡
                    // è®¡ç®—éšœç¢èŠ‚ç‚¹çš„æœ€å°å’Œæœ€å¤§Xåæ ‡
                    double minObsX = double.MaxValue;
                    double maxObsX = double.MinValue;

                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        minObsX = Math.Min(minObsX, obstacle.Position.X);
                        maxObsX = Math.Max(maxObsX, obstacle.Position.X + _config.NodeWidth);
                    }

                    // å°è¯•åœ¨å·¦ä¾§é€šè¿‡
                    double leftX = minObsX - safeDistance - 20;
                    bool leftBlocked = false;
                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        if (leftX >= obstacle.Position.X - safeDistance && leftX <= obstacle.Position.X + _config.NodeWidth + safeDistance)
                        {
                            leftBlocked = true;
                            break;
                        }
                    }

                    // å°è¯•åœ¨å³ä¾§é€šè¿‡
                    double rightX = maxObsX + safeDistance + 20;
                    bool rightBlocked = false;
                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        if (rightX >= obstacle.Position.X - safeDistance && rightX <= obstacle.Position.X + _config.NodeWidth + safeDistance)
                        {
                            rightBlocked = true;
                            break;
                        }
                    }

                    DebugHelper.WriteLine($"[GenerateVerticalPath] å·¦ä¾§é€šè¿‡X={leftX:F1}, é˜»æŒ¡={leftBlocked}");
                    DebugHelper.WriteLine($"[GenerateVerticalPath] å³ä¾§é€šè¿‡X={rightX:F1}, é˜»æŒ¡={rightBlocked}");

                    // é€‰æ‹©å¯ä»¥é€šè¿‡çš„ä¸€ä¾§ï¼Œä¿®æ”¹è·¯å¾„
                    double bypassX = double.NaN;
                    if (!leftBlocked)
                    {
                        bypassX = leftX;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] ä»å·¦ä¾§ç»•è¡?);
                    }
                    else if (!rightBlocked)
                    {
                        bypassX = rightX;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] ä»å³ä¾§ç»•è¡?);
                    }
                    else
                    {
                        DebugHelper.WriteLine($"[GenerateVerticalPath] ä¸¤ä¾§éƒ½è¢«é˜»æŒ¡ï¼Œé€‰æ‹©è·ç¦»ç›®æ ‡èŠ‚ç‚¹æ›´è¿‘çš„ä¸€ä¾?);
                        // é€‰æ‹©è·ç¦»ç›®æ ‡èŠ‚ç‚¹æ›´è¿‘çš„ä¸€ä¾?
                        double leftDistance = Math.Abs(leftX - endPoint.X);
                        double rightDistance = Math.Abs(rightX - endPoint.X);
                        bypassX = (leftDistance < rightDistance) ? leftX : rightX;
                    }

                    if (!double.IsNaN(bypassX))
                    {
                        // ç”Ÿæˆç»•è¡Œè·¯å¾„ï¼šèµ·ç‚?-> (bypassX, midY) -> (bypassX, endPoint.Y) -> endPoint
                        path.Add(new Point(bypassX, midY));
                        path.Add(new Point(bypassX, endPoint.Y));
                        path.Add(new Point(endPoint.X, endPoint.Y));
                        return path;
                    }

                    DebugHelper.WriteLine($"[GenerateVerticalPath] æ— æ³•å®Œå…¨é¿å¼€éšœç¢ï¼Œæ¥å—å½“å‰è·¯å¾„ï¼ˆå¯èƒ½è¢«PathValidatoræ‹’ç»ï¼?);
                }
            }

            DebugHelper.WriteLine($"[GenerateVerticalPath] æœ€ç»ˆmidY: {midY:F1}");

            // æ£€æŸ¥ç›®æ ‡èŠ‚ç‚¹Xæ˜¯å¦ä¸ä»»ä½•éšœç¢èŠ‚ç‚¹é‡å ï¼ˆè€ƒè™‘å®‰å…¨è·ç¦»ï¼?
            bool targetXInObstacleRange = false;
            double expandedMargin = safeDistance + _config.PathOffset + 5;

            if (obstacles != null && obstacles.Count > 0)
            {
                foreach (var obstacle in obstacles)
                {
                    if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                        continue;

                    double obsLeft = obstacle.Position.X;
                    double obsRight = obstacle.Position.X + _config.NodeWidth;

                    if (endPoint.X >= obsLeft - expandedMargin && endPoint.X <= obsRight + expandedMargin)
                    {
                        targetXInObstacleRange = true;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] âš ï¸ ç›®æ ‡èŠ‚ç‚¹X={endPoint.X:F1} åœ¨éšœç¢?{obstacle.Name} (X=[{obsLeft:F1}, {obsRight:F1}]) èŒƒå›´å†?);
                        break;
                    }
                }
            }

            // å¦‚æœç›®æ ‡èŠ‚ç‚¹Xåœ¨éšœç¢èŠ‚ç‚¹èŒƒå›´å†…ï¼Œéœ€è¦ç‰¹æ®Šçš„è·¯å¾„ç­–ç•¥
            if (targetXInObstacleRange)
            {
                DebugHelper.WriteLine($"[GenerateVerticalPath] ä½¿ç”¨ç‰¹æ®Šé¿éšœè·¯å¾„ï¼šç›®æ ‡Xä¸éšœç¢é‡å?);

                // å°è¯•ä»éšœç¢èŠ‚ç‚¹ä¸Šæ–¹æˆ–ä¸‹æ–¹ç»•è¡Œ
                // è®¡ç®—éšœç¢èŠ‚ç‚¹çš„æœ€å°å’Œæœ€å¤§X
                double minObsX = double.MaxValue;
                double maxObsX = double.MinValue;
                double minObsY = double.MaxValue;
                double maxObsY = double.MinValue;

                foreach (var obstacle in obstacles)
                {
                    if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                        continue;

                    minObsX = Math.Min(minObsX, obstacle.Position.X);
                    maxObsX = Math.Max(maxObsX, obstacle.Position.X + _config.NodeWidth);
                    minObsY = Math.Min(minObsY, obstacle.Position.Y);
                    maxObsY = Math.Max(maxObsY, obstacle.Position.Y + _config.NodeHeight);
                }

                // å°è¯•ç»•è¡Œç­–ç•¥ï¼šåœ¨éšœç¢èŠ‚ç‚¹XèŒƒå›´ä¹‹å¤–ç»•è¡Œ
                // é€‰æ‹©å·¦ä¾§è¿˜æ˜¯å³ä¾§ï¼Œå–å†³äºå“ªä¾§æœ‰è¶³å¤Ÿç©ºé—?
                bool useLeftRoute = false;
                bool useRightRoute = false;

                // æ£€æŸ¥å·¦ä¾§æ˜¯å¦æœ‰ç©ºé—´
                double leftSpace = minObsX - transitionPoint.X - safeDistance;
                if (leftSpace > 10)
                {
                    useLeftRoute = true;
                    DebugHelper.WriteLine($"[GenerateVerticalPath] å·¦ä¾§æœ?{leftSpace:F1}px ç©ºé—´ï¼Œå¯ä»¥ä»å·¦ä¾§ç»•è¡Œ");
                }

                // æ£€æŸ¥å³ä¾§æ˜¯å¦æœ‰ç©ºé—´
                double rightSpace = endPoint.X - maxObsX - safeDistance;
                if (rightSpace > 10)
                {
                    useRightRoute = true;
                    DebugHelper.WriteLine($"[GenerateVerticalPath] å³ä¾§æœ?{rightSpace:F1}px ç©ºé—´ï¼Œå¯ä»¥ä»å³ä¾§ç»•è¡Œ");
                }

                // å¦‚æœä¸¤ä¾§éƒ½æ²¡æœ‰è¶³å¤Ÿç©ºé—´ï¼Œå°è¯•è°ƒæ•´midYæ¥ç»•è¡?
                if (!useLeftRoute && !useRightRoute)
                {
                    DebugHelper.WriteLine($"[GenerateVerticalPath] ä¸¤ä¾§ç©ºé—´ä¸è¶³ï¼Œå°è¯•è°ƒæ•´Yåæ ‡ç»•è¡Œ");

                    // å°è¯•åœ¨éšœç¢èŠ‚ç‚¹YèŒƒå›´ä¹‹å¤–é€šè¿‡
                    double aboveObstacle = minObsY - safeDistance - 10;
                    double belowObstacle = maxObsY + safeDistance + 10;

                    // æ£€æŸ¥ä¸Šæ–¹æ˜¯å¦å¯ç”?
                    bool aboveAvailable = true;
                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        double obsTop = obstacle.Position.Y;
                        double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                        if (aboveObstacle >= obsTop - safeDistance && aboveObstacle <= obsBottom + safeDistance)
                        {
                            aboveAvailable = false;
                            break;
                        }
                    }

                    // æ£€æŸ¥ä¸‹æ–¹æ˜¯å¦å¯ç”?
                    bool belowAvailable = true;
                    foreach (var obstacle in obstacles)
                    {
                        if (obstacle.Id == context.SourceNode.Id || obstacle.Id == context.TargetNode.Id)
                            continue;

                        double obsTop = obstacle.Position.Y;
                        double obsBottom = obstacle.Position.Y + _config.NodeHeight;

                        if (belowObstacle >= obsTop - safeDistance && belowObstacle <= obsBottom + safeDistance)
                        {
                            belowAvailable = false;
                            break;
                        }
                    }

                    // é€‰æ‹©å¯ç”¨çš„æ–¹å?
                    if (aboveAvailable && aboveObstacle < midY)
                    {
                        midY = aboveObstacle;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] è°ƒæ•´åˆ°éšœç¢èŠ‚ç‚¹ä¸Šæ–? {midY:F1}");
                    }
                    else if (belowAvailable && belowObstacle > midY)
                    {
                        midY = belowObstacle;
                        DebugHelper.WriteLine($"[GenerateVerticalPath] è°ƒæ•´åˆ°éšœç¢èŠ‚ç‚¹ä¸‹æ–? {midY:F1}");
                    }
                    else
                    {
                        DebugHelper.WriteLine($"[GenerateVerticalPath] âš ï¸ æ— æ³•å®Œå…¨é¿å¼€éšœç¢ï¼Œä½¿ç”¨å½“å‰è·¯å¾„ï¼ˆå¯èƒ½è¢«PathValidatoræ‹’ç»ï¼?);
                    }
                }
            }

            // ç¬¬ä¸€æ®µï¼šä»è¿‡æ¸¡ç‚¹å‚ç›´ç§»åŠ¨åˆ°ä¸­é—´Yï¼ˆè¿™æ˜¯ç¬¬ä¸€ä¸ªç›´è§’è½¬æŠ˜ï¼‰
            Point midPoint1 = new Point(transitionPoint.X, midY);
            path.Add(midPoint1);

            // ç¬¬äºŒæ®µï¼šæ°´å¹³ç§»åŠ¨åˆ°ç»ˆç‚¹Xï¼ˆè¿™æ˜¯ç¬¬äºŒä¸ªç›´è§’è½¬æŠ˜ï¼?
            Point midPoint2 = new Point(endPoint.X, midY);
            path.Add(midPoint2);

            // æ·»åŠ æœ€ç»ˆè°ƒæ•´ç‚¹ï¼Œç¡®ä¿ç›´è§’æŠ˜çº¿ï¼ˆæ€»æ˜¯æ·»åŠ ï¼Œä¿è¯ä¸¤ä¸ªè¿‡æ¸¡ç‚¹ï¼?
            path.Add(new Point(endPoint.X, endPoint.Y));

            return path;
        }

        /// <summary>
        /// åˆ¤æ–­ä¸¤ä¸ªç‚¹æ˜¯å¦ç›¸åŒï¼ˆå…è®¸å°è¯¯å·®ï¼‰
        /// </summary>
        private bool IsSamePoint(Point p1, Point p2)
        {
            const double epsilon = 0.1;
            return Math.Abs(p1.X - p2.X) < epsilon && Math.Abs(p1.Y - p2.Y) < epsilon;
        }

        /// <summary>
        /// è®¡ç®—LeftToLeftçš„è¿‡æ¸¡ç‚¹ï¼šå‘å·¦æ°´å¹³ç§»åŠ¨ç¦»å¼€æºèŠ‚ç‚¹ï¼ˆä¿æŒYä¸å˜ï¼?
        /// </summary>
        private Point CalculateTransitionPointLeftToLeft(PathContext context, Point startPoint, double transitionDistance)
        {
            // å¯¹äºLeftToLeftï¼Œç¬¬ä¸€ä¸ªè¿‡æ¸¡ç‚¹åº”è¯¥å‘å·¦æ°´å¹³ç§»åŠ¨ï¼Œä¿æŒYåæ ‡ä¸æºç«¯å£ç›¸åŒ
            // è¿™æ ·ç¡®ä¿ä»æºç«¯å£åˆ°ç¬¬ä¸€ä¸ªè¿‡æ¸¡ç‚¹çš„çº¿æ®µæ˜¯æ°´å¹³çš?
            return new Point(startPoint.X - transitionDistance, startPoint.Y);
        }

        /// <summary>
        /// è®¡ç®—RightToRightçš„è¿‡æ¸¡ç‚¹ï¼šå‘å³æ°´å¹³ç§»åŠ¨ç¦»å¼€æºèŠ‚ç‚¹ï¼ˆä¿æŒYä¸å˜ï¼?
        /// </summary>
        private Point CalculateTransitionPointRightToRight(PathContext context, Point startPoint, double transitionDistance)
        {
            // å¯¹äºRightToRightï¼Œç¬¬ä¸€ä¸ªè¿‡æ¸¡ç‚¹åº”è¯¥å‘å³æ°´å¹³ç§»åŠ¨ï¼Œä¿æŒYåæ ‡ä¸æºç«¯å£ç›¸åŒ
            // è¿™æ ·ç¡®ä¿ä»æºç«¯å£åˆ°ç¬¬ä¸€ä¸ªè¿‡æ¸¡ç‚¹çš„çº¿æ®µæ˜¯æ°´å¹³çš?
            return new Point(startPoint.X + transitionDistance, startPoint.Y);
        }

        /// <summary>
        /// è®¡ç®—TopToTopçš„è¿‡æ¸¡ç‚¹ï¼šå‘ä¸Šå‚ç›´ç§»åŠ¨ç¦»å¼€æºèŠ‚ç‚¹ï¼ˆä¿æŒXä¸å˜ï¼?
        /// </summary>
        private Point CalculateTransitionPointTopToTop(PathContext context, Point startPoint, double transitionDistance)
        {
            // å¯¹äºTopToTopï¼Œç¬¬ä¸€ä¸ªè¿‡æ¸¡ç‚¹åº”è¯¥å‘ä¸Šå‚ç›´ç§»åŠ¨ï¼Œä¿æŒXåæ ‡ä¸æºç«¯å£ç›¸åŒ
            // è¿™æ ·ç¡®ä¿ä»æºç«¯å£åˆ°ç¬¬ä¸€ä¸ªè¿‡æ¸¡ç‚¹çš„çº¿æ®µæ˜¯å‚ç›´çš?
            return new Point(startPoint.X, startPoint.Y - transitionDistance);
        }

        /// <summary>
        /// è®¡ç®—BottomToBottomçš„è¿‡æ¸¡ç‚¹ï¼šå‘ä¸‹å‚ç›´ç§»åŠ¨ç¦»å¼€æºèŠ‚ç‚¹ï¼ˆä¿æŒXä¸å˜ï¼?
        /// </summary>
        private Point CalculateTransitionPointBottomToBottom(PathContext context, Point startPoint, double transitionDistance)
        {
            // å¯¹äºBottomToBottomï¼Œç¬¬ä¸€ä¸ªè¿‡æ¸¡ç‚¹åº”è¯¥å‘ä¸‹å‚ç›´ç§»åŠ¨ï¼Œä¿æŒXåæ ‡ä¸æºç«¯å£ç›¸åŒ
            // è¿™æ ·ç¡®ä¿ä»æºç«¯å£åˆ°ç¬¬ä¸€ä¸ªè¿‡æ¸¡ç‚¹çš„çº¿æ®µæ˜¯å‚ç›´çš?
            return new Point(startPoint.X, startPoint.Y + transitionDistance);
        }

        // ==================== ä¼˜åŒ–åçš„è·¯å¾„ç”Ÿæˆæ–¹æ³• ====================

        /// <summary>
        /// åˆ†æç«¯å£ä½ç½®ç±»å‹
        /// </summary>
        private PortPositionType AnalyzePortPosition(PortType port)
        {
            return port switch
            {
                PortType.LeftPort => PortPositionType.Left,
                PortType.RightPort => PortPositionType.Right,
                PortType.TopPort => PortPositionType.Top,
                PortType.BottomPort => PortPositionType.Bottom,
                _ => PortPositionType.Left  // é»˜è®¤å€?
            };
        }

        /// <summary>
        /// åˆ¤æ–­æ˜¯å¦éœ€è¦ç»•è¡ŒèŠ‚ç‚?
        /// </summary>
        private bool NeedBypassNode(PathContext context, PortPositionType sourcePortPos, PortPositionType targetPortPos,
            NodeRelativePosition relativePos, bool isSourceNode)
        {
            var node = isSourceNode ? context.SourceNode : context.TargetNode;
            double nodeLeft = node.Position.X;
            double nodeRight = node.Position.X + _config.NodeWidth;
            double nodeTop = node.Position.Y;
            double nodeBottom = node.Position.Y + _config.NodeHeight;
            double nodeCenterX = (nodeLeft + nodeRight) / 2;
            double nodeCenterY = (nodeTop + nodeBottom) / 2;

            var otherNode = isSourceNode ? context.TargetNode : context.SourceNode;
            double otherCenterX = (otherNode.Position.X + otherNode.Position.X + _config.NodeWidth) / 2;
            double otherCenterY = (otherNode.Position.Y + otherNode.Position.Y + _config.NodeHeight) / 2;

            Point endPoint = context.ArrowTailPoint;
            Point startPoint = context.StartPoint;

            // è·¯å¾„æ–¹å‘å‘é‡
            double pathDirX = endPoint.X - startPoint.X;
            double pathDirY = endPoint.Y - startPoint.Y;

            // å¦‚æœæ˜¯åˆ¤æ–­æºèŠ‚ç‚¹
            if (isSourceNode)
            {
                // æºç«¯å£åœ¨å·¦ä¾§ï¼Œè·¯å¾„å‘å·¦ç§»åŠ?â†?éœ€è¦ç»•è¡?
                if (sourcePortPos == PortPositionType.Left && pathDirX < -10)
                    return true;
                // æºç«¯å£åœ¨å³ä¾§ï¼Œè·¯å¾„å‘å³ç§»åŠ?â†?éœ€è¦ç»•è¡?
                if (sourcePortPos == PortPositionType.Right && pathDirX > 10)
                    return true;
                // æºç«¯å£åœ¨é¡¶éƒ¨ï¼Œè·¯å¾„å‘ä¸Šç§»åŠ?â†?éœ€è¦ç»•è¡?
                if (sourcePortPos == PortPositionType.Top && pathDirY < -10)
                    return true;
                // æºç«¯å£åœ¨åº•éƒ¨ï¼Œè·¯å¾„å‘ä¸‹ç§»åŠ?â†?éœ€è¦ç»•è¡?
                if (sourcePortPos == PortPositionType.Bottom && pathDirY > 10)
                    return true;
            }
            else
            {
                // ç›®æ ‡ç«¯å£åœ¨å³ä¾§ï¼Œè·¯å¾„ä»å³ä¾§è¿›å…?â†?éœ€è¦ç»•è¡?
                if (targetPortPos == PortPositionType.Right && pathDirX > 0 && endPoint.X < nodeRight)
                    return true;
                // ç›®æ ‡ç«¯å£åœ¨å·¦ä¾§ï¼Œè·¯å¾„ä»å·¦ä¾§è¿›å…?â†?éœ€è¦ç»•è¡?
                if (targetPortPos == PortPositionType.Left && pathDirX < 0 && endPoint.X > nodeLeft)
                    return true;
                // ç›®æ ‡ç«¯å£åœ¨åº•éƒ¨ï¼Œè·¯å¾„ä»åº•éƒ¨è¿›å…?â†?éœ€è¦ç»•è¡?
                if (targetPortPos == PortPositionType.Bottom && pathDirY > 0 && endPoint.Y < nodeBottom)
                    return true;
                // ç›®æ ‡ç«¯å£åœ¨é¡¶éƒ¨ï¼Œè·¯å¾„ä»é¡¶éƒ¨è¿›å…?â†?éœ€è¦ç»•è¡?
                if (targetPortPos == PortPositionType.Top && pathDirY < 0 && endPoint.Y > nodeTop)
                    return true;
            }

            // æ£€æŸ¥èŠ‚ç‚¹ç›¸å¯¹ä½ç½®å’Œç«¯å£æ–¹å‘çš„å†²çª?
            if (isSourceNode)
            {
                // æºèŠ‚ç‚¹åœ¨ç›®æ ‡èŠ‚ç‚¹å·¦ä¾§ï¼Œä½†æºç«¯å£åœ¨å³ä¾§ â†?éœ€è¦ç»•è¡?
                if (relativePos == NodeRelativePosition.LeftOfTarget && sourcePortPos == PortPositionType.Right)
                    return true;
                // æºèŠ‚ç‚¹åœ¨ç›®æ ‡èŠ‚ç‚¹å³ä¾§ï¼Œä½†æºç«¯å£åœ¨å·¦ä¾§ â†?éœ€è¦ç»•è¡?
                if (relativePos == NodeRelativePosition.RightOfTarget && sourcePortPos == PortPositionType.Left)
                    return true;
                // æºèŠ‚ç‚¹åœ¨ç›®æ ‡èŠ‚ç‚¹ä¸Šæ–¹ï¼Œä½†æºç«¯å£åœ¨åº•éƒ¨ â†?éœ€è¦ç»•è¡?
                if (relativePos == NodeRelativePosition.AboveTarget && sourcePortPos == PortPositionType.Bottom)
                    return true;
                // æºèŠ‚ç‚¹åœ¨ç›®æ ‡èŠ‚ç‚¹ä¸‹æ–¹ï¼Œä½†æºç«¯å£åœ¨é¡¶éƒ¨ â†?éœ€è¦ç»•è¡?
                if (relativePos == NodeRelativePosition.BelowTarget && sourcePortPos == PortPositionType.Top)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// è®¡ç®—å®‰å…¨åæ ‡ï¼ˆé¿å¼€èŠ‚ç‚¹ï¼?
        /// </summary>
        private double CalculateSafeCoordinate(double value, double nodeMin, double nodeMax, 
            double safeDistance, bool preferAbove)
        {
            if (preferAbove)
            {
                // ä¼˜å…ˆåœ¨ä¸Šæ–?å·¦ä¾§
                double safeValue = nodeMin - safeDistance;
                // ç¡®ä¿ä¸ä¸èŠ‚ç‚¹é‡å 
                if (safeValue >= nodeMin)
                    safeValue = nodeMin - safeDistance - 10;
                return safeValue;
            }
            else
            {
                // ä¼˜å…ˆåœ¨ä¸‹æ–?å³ä¾§
                double safeValue = nodeMax + safeDistance;
                // ç¡®ä¿ä¸ä¸èŠ‚ç‚¹é‡å 
                if (safeValue <= nodeMax)
                    safeValue = nodeMax + safeDistance + 10;
                return safeValue;
            }
        }

        /// <summary>
        /// æ£€æµ‹è·¯å¾„æ˜¯å¦ç©¿è¿‡ä»»ä½•èŠ‚ç‚?
        /// </summary>
        private bool PathCrossesAnyNode(List<Point> path, PathContext context, double safeDistance)
        {
            var allNodes = new List<WorkflowNode>();
            allNodes.Add(context.SourceNode);
            allNodes.Add(context.TargetNode);
            if (context.Obstacles != null)
            {
                allNodes.AddRange(context.Obstacles.Where(o => 
                    o.Id != context.SourceNode.Id && o.Id != context.TargetNode.Id));
            }

            // æ£€æŸ¥è·¯å¾„çš„æ¯ä¸ªçº¿æ®µ
            for (int i = 0; i < path.Count - 1; i++)
            {
                Point p1 = path[i];
                Point p2 = path[i + 1];

                foreach (var node in allNodes)
                {
                    if (LineIntersectsNode(p1, p2, node, safeDistance))
                        return true;
                }
            }

            return false;
        }

        /// <summary>
        /// æ£€æµ‹çº¿æ®µæ˜¯å¦ç©¿è¿‡èŠ‚ç‚?
        /// </summary>
        private bool LineIntersectsNode(Point p1, Point p2, WorkflowNode node, double safeDistance)
        {
            double nodeLeft = node.Position.X - safeDistance;
            double nodeRight = node.Position.X + _config.NodeWidth + safeDistance;
            double nodeTop = node.Position.Y - safeDistance;
            double nodeBottom = node.Position.Y + _config.NodeHeight + safeDistance;

            // ä½¿ç”¨åˆ†ç¦»è½´å®šç†æ£€æµ‹çº¿æ®µä¸çŸ©å½¢çš„ç›¸äº?
            // é¦–å…ˆæ£€æŸ¥çº¿æ®µçš„ä¸¤ä¸ªç«¯ç‚¹æ˜¯å¦åœ¨çŸ©å½¢å†…
            bool p1Inside = p1.X >= nodeLeft && p1.X <= nodeRight && p1.Y >= nodeTop && p1.Y <= nodeBottom;
            bool p2Inside = p2.X >= nodeLeft && p2.X <= nodeRight && p2.Y >= nodeTop && p2.Y <= nodeBottom;

            if (p1Inside || p2Inside)
                return true;

            // æ£€æŸ¥çº¿æ®µæ˜¯å¦ä¸çŸ©å½¢çš„å››æ¡è¾¹ç›¸äº¤
            if (LineIntersectsLine(p1, p2, new Point(nodeLeft, nodeTop), new Point(nodeRight, nodeTop))) // ä¸Šè¾¹
                return true;
            if (LineIntersectsLine(p1, p2, new Point(nodeRight, nodeTop), new Point(nodeRight, nodeBottom))) // å³è¾¹
                return true;
            if (LineIntersectsLine(p1, p2, new Point(nodeLeft, nodeBottom), new Point(nodeRight, nodeBottom))) // ä¸‹è¾¹
                return true;
            if (LineIntersectsLine(p1, p2, new Point(nodeLeft, nodeTop), new Point(nodeLeft, nodeBottom))) // å·¦è¾¹
                return true;

            return false;
        }

        /// <summary>
        /// æ£€æµ‹ä¸¤æ¡çº¿æ®µæ˜¯å¦ç›¸äº?
        /// </summary>
        private bool LineIntersectsLine(Point p1, Point p2, Point p3, Point p4)
        {
            // ä½¿ç”¨å‰ç§¯æ£€æµ?
            double d1 = CrossProduct(p3, p4, p1);
            double d2 = CrossProduct(p3, p4, p2);
            double d3 = CrossProduct(p1, p2, p3);
            double d4 = CrossProduct(p1, p2, p4);

            // å¦‚æœä¸¤æ¡çº¿æ®µè·¨ç«‹ï¼Œåˆ™ç›¸äº¤
            if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&
                ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0)))
                return true;

            return false;
        }

        /// <summary>
        /// è®¡ç®—å‰ç§¯
        /// </summary>
        private double CrossProduct(Point p1, Point p2, Point p3)
        {
            return (p2.X - p1.X) * (p3.Y - p1.Y) - (p2.Y - p1.Y) * (p3.X - p1.X);
        }

        /// <summary>
        /// ç”ŸæˆLå‹è·¯å¾„ï¼ˆ3ç‚¹ï¼‰
        /// </summary>
        private List<Point> GenerateLShapePath(PathContext context, Point startPoint, Point endPoint, PortCombinationType portCombo)
        {
            var path = new List<Point>();

            switch (portCombo)
            {
                case PortCombinationType.LeftToRight:
                case PortCombinationType.RightToLeft:
                    // æ°´å¹³æ–¹å‘ä¼˜å…ˆ
                    path.Add(new Point(endPoint.X, startPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.TopToBottom:
                case PortCombinationType.BottomToTop:
                    // å‚ç›´æ–¹å‘ä¼˜å…ˆ
                    path.Add(new Point(startPoint.X, endPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.LeftToTop:
                case PortCombinationType.LeftToBottom:
                case PortCombinationType.RightToTop:
                case PortCombinationType.RightToBottom:
                    // å·?å³å‡ºå‘ï¼šå…ˆæ°´å¹³åå‚ç›´
                    path.Add(new Point(endPoint.X, startPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.TopToLeft:
                case PortCombinationType.TopToRight:
                case PortCombinationType.BottomToLeft:
                case PortCombinationType.BottomToRight:
                    // ä¸?ä¸‹å‡ºå‘ï¼šå…ˆå‚ç›´åæ°´å¹³
                    path.Add(new Point(startPoint.X, endPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.LeftToLeft:
                case PortCombinationType.RightToRight:
                    // åŒå‘ï¼šå…ˆå‚ç›´é¿å¼€
                    path.Add(new Point(startPoint.X, endPoint.Y));
                    path.Add(endPoint);
                    break;

                case PortCombinationType.TopToTop:
                case PortCombinationType.BottomToBottom:
                    // åŒå‘ï¼šå…ˆæ°´å¹³é¿å¼€
                    path.Add(new Point(endPoint.X, startPoint.Y));
                    path.Add(endPoint);
                    break;

                default:
                    // é»˜è®¤ï¼šæ ¹æ®ç›¸å¯¹ä½ç½®é€‰æ‹©
                    double deltaX = endPoint.X - startPoint.X;
                    double deltaY = endPoint.Y - startPoint.Y;
                    if (Math.Abs(deltaX) > Math.Abs(deltaY))
                    {
                        path.Add(new Point(endPoint.X, startPoint.Y));
                    }
                    else
                    {
                        path.Add(new Point(startPoint.X, endPoint.Y));
                    }
                    path.Add(endPoint);
                    break;
            }

            return path;
        }

        /// <summary>
        /// ç”ŸæˆZå‹è·¯å¾„ç»•è¡ŒæºèŠ‚ç‚¹ï¼?ç‚¹ï¼‰
        /// </summary>
        private List<Point> GenerateZShapePathBypassSource(PathContext context, Point startPoint, 
            Point endPoint, PortPositionType sourcePortPos)
        {
            var path = new List<Point>();
            double safeDistance = BaseSafeDistance;

            double sourceLeft = context.SourceNode.Position.X;
            double sourceRight = context.SourceNode.Position.X + _config.NodeWidth;
            double sourceTop = context.SourceNode.Position.Y;
            double sourceBottom = context.SourceNode.Position.Y + _config.NodeHeight;

            Point bypassPoint;

            // æ ¹æ®æºç«¯å£ä½ç½®é€‰æ‹©ç»•è¡Œç‚?
            switch (sourcePortPos)
            {
                case PortPositionType.Left:
                    // ä»å·¦ä¾§ç»•è¡?
                    bypassPoint = new Point(sourceLeft - safeDistance, startPoint.Y);
                    path.Add(bypassPoint);
                    path.Add(new Point(bypassPoint.X, endPoint.Y));
                    break;

                case PortPositionType.Right:
                    // ä»å³ä¾§ç»•è¡?
                    bypassPoint = new Point(sourceRight + safeDistance, startPoint.Y);
                    path.Add(bypassPoint);
                    path.Add(new Point(bypassPoint.X, endPoint.Y));
                    break;

                case PortPositionType.Top:
                    // ä»ä¸Šæ–¹ç»•è¡?
                    bypassPoint = new Point(startPoint.X, sourceTop - safeDistance);
                    path.Add(bypassPoint);
                    path.Add(new Point(endPoint.X, bypassPoint.Y));
                    break;

                case PortPositionType.Bottom:
                    // ä»ä¸‹æ–¹ç»•è¡?
                    bypassPoint = new Point(startPoint.X, sourceBottom + safeDistance);
                    path.Add(bypassPoint);
                    path.Add(new Point(endPoint.X, bypassPoint.Y));
                    break;
            }

            path.Add(endPoint);
            return path;
        }

        /// <summary>
        /// ç”ŸæˆZå‹è·¯å¾„ç»•è¡Œç›®æ ‡èŠ‚ç‚¹ï¼ˆ4ç‚¹ï¼‰
        /// </summary>
        private List<Point> GenerateZShapePathBypassTarget(PathContext context, Point startPoint, 
            Point endPoint, PortPositionType targetPortPos)
        {
            var path = new List<Point>();
            double safeDistance = BaseSafeDistance;

            double targetLeft = context.TargetNode.Position.X;
            double targetRight = context.TargetNode.Position.X + _config.NodeWidth;
            double targetTop = context.TargetNode.Position.Y;
            double targetBottom = context.TargetNode.Position.Y + _config.NodeHeight;

            Point bypassPoint;

            // æ ¹æ®ç›®æ ‡ç«¯å£ä½ç½®é€‰æ‹©ç»•è¡Œç‚?
            switch (targetPortPos)
            {
                case PortPositionType.Left:
                    // ä»å·¦ä¾§ç»•è¡?
                    bypassPoint = new Point(targetLeft - safeDistance, endPoint.Y);
                    path.Add(new Point(startPoint.X, bypassPoint.Y));
                    path.Add(bypassPoint);
                    break;

                case PortPositionType.Right:
                    // ä»å³ä¾§ç»•è¡?
                    bypassPoint = new Point(targetRight + safeDistance, endPoint.Y);
                    path.Add(new Point(startPoint.X, bypassPoint.Y));
                    path.Add(bypassPoint);
                    break;

                case PortPositionType.Top:
                    // ä»ä¸Šæ–¹ç»•è¡?
                    bypassPoint = new Point(endPoint.X, targetTop - safeDistance);
                    path.Add(new Point(bypassPoint.X, startPoint.Y));
                    path.Add(bypassPoint);
                    break;

                case PortPositionType.Bottom:
                    // ä»ä¸‹æ–¹ç»•è¡?
                    bypassPoint = new Point(endPoint.X, targetBottom + safeDistance);
                    path.Add(new Point(bypassPoint.X, startPoint.Y));
                    path.Add(bypassPoint);
                    break;
            }

            path.Add(endPoint);
            return path;
        }

        /// <summary>
        /// ç”ŸæˆUå‹è·¯å¾„ç»•è¡Œä¸¤ä¸ªèŠ‚ç‚¹ï¼ˆ5ç‚¹ï¼‰
        /// </summary>
        private List<Point> GenerateUShapePathBypassBoth(PathContext context, Point startPoint, 
            Point endPoint, PortPositionType sourcePortPos, PortPositionType targetPortPos)
        {
            var path = new List<Point>();
            double safeDistance = BaseSafeDistance;

            double sourceLeft = context.SourceNode.Position.X;
            double sourceRight = context.SourceNode.Position.X + _config.NodeWidth;
            double sourceTop = context.SourceNode.Position.Y;
            double sourceBottom = context.SourceNode.Position.Y + _config.NodeHeight;

            double targetLeft = context.TargetNode.Position.X;
            double targetRight = context.TargetNode.Position.X + _config.NodeWidth;
            double targetTop = context.TargetNode.Position.Y;
            double targetBottom = context.TargetNode.Position.Y + _config.NodeHeight;

            Point sourceBypass;
            Point targetBypass;

            // æ ¹æ®æºç«¯å£ä½ç½®é€‰æ‹©ç¬¬ä¸€ä¸ªç»•è¡Œç‚¹
            switch (sourcePortPos)
            {
                case PortPositionType.Left:
                    sourceBypass = new Point(sourceLeft - safeDistance, startPoint.Y);
                    break;
                case PortPositionType.Right:
                    sourceBypass = new Point(sourceRight + safeDistance, startPoint.Y);
                    break;
                case PortPositionType.Top:
                    sourceBypass = new Point(startPoint.X, sourceTop - safeDistance);
                    break;
                case PortPositionType.Bottom:
                    sourceBypass = new Point(startPoint.X, sourceBottom + safeDistance);
                    break;
                default:
                    sourceBypass = startPoint;
                    break;
            }

            // æ ¹æ®ç›®æ ‡ç«¯å£ä½ç½®é€‰æ‹©ç¬¬äºŒä¸ªç»•è¡Œç‚¹
            switch (targetPortPos)
            {
                case PortPositionType.Left:
                    targetBypass = new Point(targetLeft - safeDistance, endPoint.Y);
                    break;
                case PortPositionType.Right:
                    targetBypass = new Point(targetRight + safeDistance, endPoint.Y);
                    break;
                case PortPositionType.Top:
                    targetBypass = new Point(endPoint.X, targetTop - safeDistance);
                    break;
                case PortPositionType.Bottom:
                    targetBypass = new Point(endPoint.X, targetBottom + safeDistance);
                    break;
                default:
                    targetBypass = endPoint;
                    break;
            }

            // è¿æ¥å››ä¸ªç‚¹ï¼šèµ·ç‚¹ â†?æºç»•è¡Œç‚¹ â†?ç›®æ ‡ç»•è¡Œç‚?â†?ç»ˆç‚¹
            path.Add(sourceBypass);
            path.Add(targetBypass);
            path.Add(endPoint);

            return path;
        }

        /// <summary>
        /// ç”Ÿæˆé€šç”¨è·¯å¾„ï¼ˆä½¿ç”¨ç»Ÿä¸€çš„å†³ç­–é€»è¾‘ï¼? ä¼˜åŒ–ç‰ˆæœ¬
        /// </summary>
        private List<Point> GenerateUniversalPathFromTransition_Optimized(PathContext context, PortCombinationType portCombo,
            NodeRelativePosition relativePos, Point transitionPoint)
        {
            Point startPoint = context.StartPoint;
            Point endPoint = context.ArrowTailPoint;
            double safeDistance = BaseSafeDistance;

            // å¦‚æœèµ·ç‚¹å’Œè¿‡æ¸¡ç‚¹ç›¸åŒï¼Œç›´æ¥ä»èµ·ç‚¹å¼€å§?
            Point actualStart = IsSamePoint(startPoint, transitionPoint) ? startPoint : transitionPoint;

            // åˆ†æç«¯å£ä½ç½®
            var sourcePortPos = AnalyzePortPosition(context.SourcePort);
            var targetPortPos = AnalyzePortPosition(context.TargetPort);

            // åˆ¤æ–­æ˜¯å¦éœ€è¦ç»•è¡ŒæºèŠ‚ç‚¹æˆ–ç›®æ ‡èŠ‚ç‚?
            bool needBypassSource = NeedBypassNode(context, sourcePortPos, targetPortPos, relativePos, true);
            bool needBypassTarget = NeedBypassNode(context, sourcePortPos, targetPortPos, relativePos, false);

            DebugHelper.WriteLine($"[GenerateUniversalPath] æºç«¯å? {sourcePortPos}, ç›®æ ‡ç«¯å£: {targetPortPos}");
            DebugHelper.WriteLine($"[GenerateUniversalPath] éœ€è¦ç»•è¡ŒæºèŠ‚ç‚¹: {needBypassSource}, éœ€è¦ç»•è¡Œç›®æ ‡èŠ‚ç‚? {needBypassTarget}");

            // æ ¹æ®ç»•è¡Œéœ€æ±‚é€‰æ‹©è·¯å¾„ç±»å‹
            if (!needBypassSource && !needBypassTarget)
            {
                // æ— éœ€ç»•è¡Œï¼šä½¿ç”¨Lå‹è·¯å¾„ï¼ˆ3ç‚¹ï¼‰
                DebugHelper.WriteLine($"[GenerateUniversalPath] ä½¿ç”¨Lå‹è·¯å¾„ï¼ˆæ— éœ€ç»•è¡Œï¼?);
                var path = GenerateLShapePath(context, actualStart, endPoint, portCombo);
                if (actualStart != startPoint)
                    path.Insert(0, actualStart);
                return path;
            }
            else if (needBypassSource && !needBypassTarget)
            {
                // åªç»•è¡ŒæºèŠ‚ç‚¹ï¼šä½¿ç”¨Zå‹è·¯å¾„ï¼ˆ4ç‚¹ï¼‰
                DebugHelper.WriteLine($"[GenerateUniversalPath] ä½¿ç”¨Zå‹è·¯å¾„ç»•è¡ŒæºèŠ‚ç‚¹");
                var path = GenerateZShapePathBypassSource(context, actualStart, endPoint, sourcePortPos);
                if (actualStart != startPoint)
                    path.Insert(0, actualStart);
                return path;
            }
            else if (!needBypassSource && needBypassTarget)
            {
                // åªç»•è¡Œç›®æ ‡èŠ‚ç‚¹ï¼šä½¿ç”¨Zå‹è·¯å¾„ï¼ˆ4ç‚¹ï¼‰
                DebugHelper.WriteLine($"[GenerateUniversalPath] ä½¿ç”¨Zå‹è·¯å¾„ç»•è¡Œç›®æ ‡èŠ‚ç‚?);
                var path = GenerateZShapePathBypassTarget(context, actualStart, endPoint, targetPortPos);
                if (actualStart != startPoint)
                    path.Insert(0, actualStart);
                return path;
            }
            else
            {
                // ç»•è¡Œä¸¤ä¸ªèŠ‚ç‚¹ï¼šä½¿ç”¨Uå‹è·¯å¾„ï¼ˆ5ç‚¹ï¼‰
                DebugHelper.WriteLine($"[GenerateUniversalPath] ä½¿ç”¨Uå‹è·¯å¾„ç»•è¡Œä¸¤ä¸ªèŠ‚ç‚?);
                var path = GenerateUShapePathBypassBoth(context, actualStart, endPoint, sourcePortPos, targetPortPos);
                if (actualStart != startPoint)
                    path.Insert(0, actualStart);
                return path;
            }
        }
    }
}
